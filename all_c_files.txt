/* ======= fichier: ./Exec/builtin2.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin2.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/21 21:42:28 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/16 23:49:33 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	built_path(char *newpath, t_data *data)
{
	char		cwd[1024];
	struct stat	sb;

	if (access(newpath, F_OK) != 0)
	{
		printf("cd: %s: No such file or directory\n", newpath);
		g_exit_status = 1;
		return ;
	}
	if (stat(newpath, &sb) != 0 || !S_ISDIR(sb.st_mode))
	{
		printf("bash: cd: %s: Not a directory\n", newpath);
		g_exit_status = 1;
		return ;
	}
	if (access(newpath, X_OK) != 0)
	{
		printf("bash: cd: %s: Permission denied\n", newpath);
		g_exit_status = 126;
		return ;
	}
	getcwd(cwd, sizeof(cwd));
	chdir(newpath);
	updatepwd(&data->env, cwd);
}

static char	*handle_cd_null(void)
{
	const char	*home;

	home = getenv("HOME");
	if (!home)
	{
		printf("cd: HOME not set\n");
		g_exit_status = 1;
		return (NULL);
	}
	return ((char *)home);
}

static char	*handle_cd_oldpwd(t_data *data, bool *must_free, char *newpath)
{
	t_env	*old;

	old = find_env_var(data->env, "OLDPWD");
	if (!old || !old->value)
	{
		printf("cd: OLDPWD not set\n");
		g_exit_status = 1;
		return (NULL);
	}
	printf("%s\n", old->value);
	newpath = ft_strdup(old->value);
	if (!newpath)
		malloc_failed(data);
	*must_free = true;
	return (newpath);
}

static char	*handle_cd_home(char *newpath, t_data *data, bool *must_free)
{
	const char	*home;
	char		*expanded_path;

	home = getenv("HOME");
	if (!home)
	{
		printf("cd: HOME not set\n");
		g_exit_status = 1;
		return (NULL);
	}
	expanded_path = malloc(ft_strlen(home) + ft_strlen(newpath));
	if (!expanded_path)
		malloc_failed(data);
	ft_strcpy(expanded_path, home);
	ft_strcat(expanded_path, newpath + 1);
	newpath = expanded_path;
	*must_free = true;
	return (expanded_path);
}

void	builtin_cd(char *newpath, t_data *data)
{
	bool		must_free;
	int			count;

	must_free = false;
	count = 0;
	while (data->cmd->args[count])
		count++;
	if (count > 2)
	{
		printf("%s: too many arguments\n", *data->cmd->args);
		g_exit_status = 1;
		return ;
	}
	if (newpath == NULL)
		newpath = handle_cd_null();
	else if (newpath[0] == '-')
		newpath = handle_cd_oldpwd(data, &must_free, newpath);
	else if (newpath[0] == '~')
		newpath = handle_cd_home(newpath, data, &must_free);
	if (newpath)
		built_path(newpath, data);
	if (must_free)
		free(newpath);
}


/* ======= fichier: ./Exec/builtin.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/26 17:07:27 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/16 23:40:26 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	isbuiltin(t_data *data)
{
	char	*cmd;

	if (!data || !data->cmd || !data->cmd->name)
		return (0);
	cmd = data->cmd->name;
	return (ft_strcmp(cmd, "echo") == 0 || ft_strcmp(cmd, "pwd") == 0
		|| ft_strcmp(cmd, "env") == 0 || ft_strcmp(cmd, "exit") == 0
		|| ft_strcmp(cmd, "cd") == 0 || ft_strcmp(cmd, "export") == 0
		|| ft_strcmp(cmd, "unset") == 0);
}

void	exec_builtin(t_data *data)
{
	t_cmd	*cmd;
	t_env	*env_list;

	env_list = data->env;
	cmd = data->cmd;
	if (!cmd || !cmd->name)
		exit(0);
	if (ft_strcmp(cmd->name, "echo") == 0)
		builtin_echo(data);
	else if (ft_strcmp(cmd->name, "pwd") == 0)
		builtin_pwd();
	else if (ft_strcmp(cmd->name, "env") == 0)
		builtin_env(env_list, data);
	else if (ft_strcmp(cmd->name, "exit") == 0)
		builtin_exit(data);
	else if (ft_strcmp(cmd->name, "cd") == 0)
		builtin_cd(cmd->args[1], data);
	else if (ft_strcmp(cmd->name, "export") == 0)
		builtin_export(data, &env_list, cmd);
	else if (ft_strcmp(cmd->name, "unset") == 0)
		builtin_unset(&data->env, cmd);
}

int	is_numeric(const char *str)
{
	int	i;

	i = 0;
	if (!str)
		return (0);
	if (str[i] == '+' || str[i] == '-')
		i++;
	if (!str[i])
		return (0);
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}

static int	validate_exit_code(t_data *data, int *exit_code)
{
	if (!is_numeric(data->cmd->args[1]))
	{
		printf("exit: %s: numeric argument required\n", data->cmd->args[1]);
		free_all(data, 2, true);
		return (0);
	}
	else if (!ft_atoi_safe(data->cmd->args[1], exit_code))
	{
		printf("exit: %s: numeric argument required\n", data->cmd->args[1]);
		free_all(data, 2, true);
		return (0);
	}
	return (1);
}

void	builtin_exit(t_data *data)
{
	int	exit_code;

	printf("exit\n");
	if (data->cmd->args[1])
	{
		if (!validate_exit_code(data, &exit_code))
			return ;
		else if (data->cmd->args[2])
		{
			printf("bash: exit: too many arguments\n");
			g_exit_status = 1;
		}
		else
		{
			exit_code = ft_atoi(data->cmd->args[1]) % 256;
			if (exit_code < 0)
				exit_code += 256;
			free_all(data, exit_code, true);
		}
	}
	else
		free_all(data, g_exit_status, true);
}


/* ======= fichier: ./Exec/builtin4.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin4.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aboutale <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/12 18:02:27 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/12 18:02:30 by aboutale         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	unset(t_env **env_list, char *name )
{
	t_env	*current;
	t_env	*previous;

	current = *env_list;
	previous = NULL;
	while (current)
	{
		if (ft_strcmp(current->name, name) == 0)
		{
			if (previous)
				previous->next = current->next;
			else
				*env_list = current->next;
			free(current->name);
			free(current->value);
			free(current);
			break ;
		}
		previous = current;
		current = current->next;
	}
}

void	builtin_unset(t_env **env_list, t_cmd *cmd)
{
	char	*name;
	int		i;

	if (!cmd->args || !cmd->args[1])
		return ;
	i = 1;
	while (cmd->args[i])
	{
		name = cmd->args[i];
		unset(env_list, name);
		i++;
	}
}

void	builtin_env( t_env *env_list, t_data *data)
{
	t_cmd	*cmd;

	cmd = data->cmd;
	if (cmd->args[1] && ft_strcmp(cmd->args[1], "env") != 0)
		printf("env: â€˜%sâ€™: No such file or directory\n", cmd->args[1]);
	else
	{
		while (env_list)
		{
			if (env_list->value != NULL)
				printf("%s=%s\n", env_list->name, env_list->value);
			env_list = env_list->next;
		}
		printf("_=/usr/bin/env\n");
	}
}

void	emptyenv(t_data *data, t_env **env_list)
{
	char	*cwd;

	cwd = getcwd(NULL, 0);
	if (!cwd)
		malloc_failed(data);
	if (*env_list == NULL)
	{
		add_env_var(data, env_list, "PWD", cwd);
		add_env_var(data, env_list, "PATH", "/usr/bin:/bin");
	}
	t_env *pwd = find_env_var(*env_list, "PWD");
	if (pwd && pwd->value)
		chdir(pwd->value);
	free(cwd);
}

void	builtin_pwd(void)
{
	char	*cwd;

	cwd = getcwd(NULL, 0);
	if (cwd)
	{
		printf("%s\n", cwd);
		free(cwd);
	}
	else
		perror("cwd");
}


/* ======= fichier: ./Exec/builtin3.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin3.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 22:18:28 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/17 02:06:18 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	antislash(const char *str, int i)
{
	int	j;
	int	b_slash;

	j = 0;
	b_slash = 0;
	while (str[i] == '\\')
	{
		b_slash++;
		i++;
	}
	while (j < (b_slash / 2))
	{
		ft_putchar ('\\');
		j++;
	}
	if (b_slash % 2 == 1)
	{
		if (str[i] != '\0')
			ft_putchar(str[i++]);
	}
	else if (str[i] != '\0')
		ft_putchar(str[i++]);
	return (i);
}

void	print_antislash(const char *str)
{
	int	i;

	i = 0;
	while (str[i])
		i = antislash(str, i);
}

void	echo(t_env *env_list, int i, t_cmd *cmd, t_data *data)
{
	(void)data;
	(void)env_list;
	if (cmd->args[i][0] == '\\')
	{
		if (cmd->args[i][1] >= 'a' && cmd->args[i][1] <= 'z')
			printf("%s", &cmd->args[i][1]);
		else
			print_antislash(&cmd->args[i][1]);
	}
	else
		printf("%s", cmd->args[i]);
}

int	check_newline(char **args, int *i)
{
	int	j;
	int	newline ;

	newline = 1;
	while (args[*i] && args[*i][0] == '-' && args[*i][1] == 'n')
	{
		j = 1;
		while (args[*i][j] == 'n')
		{
			j++;
			g_exit_status = 0;
		}
		if (args[*i][j] != '\0')
			break ;
		newline = 0;
		(*i)++;
	}
	return (newline);
}

void	builtin_echo(t_data *data)
{
	int		i;
	int		newline;
	char	**args;
	t_cmd	*cmd;
	t_env	*env_list;

	cmd = data->cmd;
	env_list = data->env;
	i = 1;
	args = cmd->args;
	newline = check_newline(args, &i);
	while (args[i])
	{
		echo(env_list, i, cmd, data);
		if (cmd->args[i + 1])
			printf(" ");
		i++;
	}
	if (newline)
	{
		printf("\n");
		g_exit_status = 0;
	}
}


/* ======= fichier: ./Exec/exec.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/20 20:57:16 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/17 21:04:07 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	parent_and_wait(int status, char *path, t_data *data, pid_t pid)
{
	ignore_sigint();
	waitpid(pid, &status, 0);
	if (data->cmd->fd_in != STDIN_FILENO)
	{
   	 	close(data->cmd->fd_in);
   		data->cmd->fd_in = STDIN_FILENO;
	}
	handle_status_and_print(status);
	free(path);
	if (data->cmd->fd_in != STDIN_FILENO)
		close(data->cmd->fd_in);
	if (data->cmd->fd_out != STDOUT_FILENO)
		close(data->cmd->fd_out);
	if (WIFEXITED(status))
		g_exit_status = WEXITSTATUS(status);
	else if (WIFSIGNALED(status))
		g_exit_status = 128 + WTERMSIG(status);
}

void	extern_childprocess(t_data *data, char *path, t_env *env, char **args)
{
	if (data->cmd->fd_in != STDIN_FILENO)
	{
		dup2(data->cmd->fd_in, STDIN_FILENO);
		close(data->cmd->fd_in);
	}
	if (data->cmd->fd_out != STDOUT_FILENO)
	{
		dup2(data->cmd->fd_out, STDOUT_FILENO);
		close(data->cmd->fd_out);
	}
	reset_signals_to_default();
	execve(path, args, convert_env(env));
	free_all(data, g_exit_status, true);
}

bool	have_no_permission(char *cmd_path)
{
	if (access(cmd_path, F_OK) != 0)
	{
		printf("minishell: %s: No such file or directory\n", cmd_path);
		g_exit_status = 127;
		return (true);
	}
	if (access(cmd_path, X_OK) != 0)
	{
		printf("minishell: %s: Permission denied\n", cmd_path);
		g_exit_status = 126;
		return (true);
	}
	return (false);
}

void	launch_extern_command(char **args, t_env *env, t_data *data)
{
	pid_t	pid;
	int		status;
	char	*path;

	status = 0;
	if (ft_strchr(args[0], '/'))
		path = ft_strdup(args[0]);
	else
		path = getpath(args[0], data);
	if (!path)
	{
		printf("%s: command not found\n", args[0]);
		g_exit_status = 127;

		if (data->cmd->fd_out != STDOUT_FILENO)
		{
			close(data->cmd->fd_out);
			data->cmd->fd_out = STDOUT_FILENO;
		}
		if (data->cmd->fd_in != STDIN_FILENO)
		{
			close(data->cmd->fd_in);
			data->cmd->fd_in = STDIN_FILENO;
		}
		/* if (data->cmd->fd_out != STDOUT_FILENO)
			close(data->cmd->fd_out);
		if (data->cmd->fd_in != STDIN_FILENO)
			close(data->cmd->fd_in); */
		return ;
	}
	if (is_a_directory(path, args) || have_no_permission(path))
		return (free(path));
	pid = fork();
	if (pid == -1)
		return (perror("fork"), g_exit_status = 1, free(path));
	if (pid == 0)
		extern_childprocess(data, path, env, args);
	else
		parent_and_wait(status, path, data, pid);
}

void	exec_extern_command(char **args, t_env *env, t_data *data)
{
	if (!args || !args[0] || args[0][0] == '\0')
	{
		printf("'' command not found\n");
		g_exit_status = 127;
		return ;
	}
	if (ft_strcmp(args[0], "\\n") == 0)
	{
		printf("n : command not found\n");
		g_exit_status = 127;
		return ;
	}
	launch_extern_command(args, env, data);
}



/* ======= fichier: ./Exec/envp.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   envp.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 15:43:10 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/03 20:37:30 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

t_env	*create_env_var(t_data *data, char *name, char *value)
{
	t_env	*new_var;

	new_var = malloc(sizeof(t_env));
	if (!new_var)
	{
		free(name);
		malloc_failed(data);
	}
	new_var->name = ft_strdup(name);
	new_var->value = ft_strdup(value);
	if (!new_var->name || (value != NULL && !new_var->value))
	{
		free(name);
		free_env(&new_var);
		malloc_failed(data);
	}
	new_var->next = NULL;
	return (new_var);
}

void	add_env_var(t_data *data, t_env **env_list, char *name, char *value)
{
	t_env	*new_var;
	t_env	*tmp;

	new_var = create_env_var(data, name, value);
	if (!*env_list)
	{
		*env_list = new_var;
		return ;
	}
	tmp = *env_list;
	while (tmp->next)
		tmp = tmp->next;
	tmp->next = new_var;
}

void	copy_env(t_env *tmp, char **envir)
{
	int		i;
	size_t	len;

	i = 0;
	while (tmp)
	{
		if (tmp->value != NULL)
		{
			len = ft_strlen(tmp->name) + ft_strlen(tmp->value) + 2;
			envir[i] = malloc(len);
			if (!envir[i])
			{
				perror("malloc");
				exit(EXIT_FAILURE);
			}
			ft_strcpy(envir[i], tmp->name);
			ft_strcat(envir[i], "=");
			ft_strcat(envir[i], tmp->value);
			i++;
		}
		tmp = tmp->next;
	}
}

char	**convert_env(t_env *env_list)
{
	int		count;
	t_env	*tmp;
	char	**envir;

	tmp = env_list;
	count = 0;
	while (tmp)
	{
		if (tmp->value != NULL)
			count++;
		tmp = tmp->next;
	}
	envir = malloc((count + 1) * sizeof(char *));
	if (!envir)
	{
		perror("malloc");
		exit(EXIT_FAILURE);
	}
	tmp = env_list;
	copy_env(env_list, envir);
	envir[count] = NULL;
	return (envir);
}

void	parse_env(char **envp, t_data *data)
{
	int		i;
	char	*name;
	char	*value;
	char	*equal_pos;

	i = 0;
	while (envp[i])
	{
		equal_pos = ft_strchr(envp[i], '=');
		if (!equal_pos)
		{
			i++;
			continue ;
		}
		name = ft_substr(envp[i], 0, equal_pos - envp[i]);
		if (!name)
			malloc_failed(data);
		value = equal_pos + 1;
		add_env_var(data, &data->env, name, value);
		free(name);
		i++;
	}
}


/* ======= fichier: ./Exec/envp2.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   envp2.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/23 21:13:05 by aboutale          #+#    #+#             */
/*   Updated: 2025/04/29 19:42:32 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

char	*getenvp(t_env *list, char *name)
{
	while (list)
	{
		if (ft_strcmp(list->name, name) == 0)
			return (list->value);
		list = list->next;
	}
	return (NULL);
}

void	swap_env(t_env *a, t_env *b)
{
	char	*tmp;

	tmp = a->name;
	a->name = b->name;
	b->name = tmp;
	tmp = a->value;
	a->value = b->value;
	b->value = tmp;
}

void	sort_env(t_env **env_list)
{
	t_env	*current ;
	t_env	*nextnode;
	int		swap;

	swap = 1;
	while (swap)
	{
		swap = 0;
		current = *env_list;
		while (current->next)
		{
			nextnode = current->next;
			if (ft_strcmp(current->name, nextnode->name) > 0)
			{
				swap_env(current, nextnode);
				swap = 1;
			}
			current = current->next;
		}
	}
}

void	free_env_list(t_env *env_list)
{
	t_env	*tmp;

	while (env_list)
	{
		tmp = env_list;
		free(tmp->name);
		free(tmp->value);
		env_list = env_list->next;
		free(tmp);
	}
}

void	builtin_export(t_data *data, t_env **env_list, t_cmd *cmd)
{
	if (!cmd->args[1])
		built_export(data, *env_list);
	else
		built_export2(data, env_list, cmd->args);
}


/* ======= fichier: ./Exec/exec3.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec3.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/12 18:16:31 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/13 13:25:56 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	ft_atoi_safe(const char *str, int *out)
{
	int			i;
	int			sign;
	int			digit;
	long long	res;

	i = 0;
	sign = 1;
	res = 0;
	if (!str || !*str)
		return (0);
	while (str[i] == ' ' || (str[i] >= 9 && str[i] <= 13))
		i++;
	if (str[i] == '+' || str[i] == '-')
		if (str[i++] == '-')
			sign = -1;
	while (str[i] >= '0' && str[i] <= '9')
	{
		digit = str[i++] - '0';
		res = res * 10 + digit;
		if ((sign == 1 && res > INT_MAX) || (sign == -1 && (-res) < INT_MIN))
			return (0);
	}
	*out = res * sign;
	return (1);
}

void	shlvl_verification(t_env *shlvl, int *lvl)
{
	if (ft_isnumeric(shlvl->value) && ft_atoi_safe(shlvl->value, lvl))
	{
		if (*lvl >= 999)
		{
			(*lvl)++;
			printf("warning: shell level (%d)", *lvl);
			printf(" too high, resetting to 1\n");
			*lvl = 1;
		}
		else if (*lvl < 0)
			*lvl = 0;
		else
			(*lvl)++;
	}
}

void	execshell(t_data *data, t_env **env_list)
{
	t_env	*shlvl;
	int		lvl;
	char	*new_val;
	t_env	*pwd;
	char *cwd;

	cwd = getcwd(NULL, 0);
	if (!cwd)
		malloc_failed(data);

	shlvl = find_env_var(*env_list, "SHLVL");
	if (!shlvl)
	{
		add_env_var(data, env_list, "SHLVL", "1");
		return ;
	}
	else
	{
		lvl = 1;
		shlvl_verification(shlvl, &lvl);
		new_val = ft_itoa(lvl);
		if (!new_val)
			malloc_failed(data);
		free(shlvl->value);
		shlvl->value = new_val;
	}
	pwd = find_env_var(*env_list, "PWD");
	if (!pwd)
		add_env_var(data, env_list, "PWD", cwd);
	free(cwd);

}


/* ======= fichier: ./Exec/export2.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export2.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/21 21:47:12 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/16 23:45:18 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	update_env_var(t_env **env_list, char *name, char *value)
{
	t_env	*current;

	current = *env_list;
	while (current)
	{
		/* if (current->value == NULL)
			return ; */
		if (ft_strcmp(current->name, name) == 0)
		{
			free(current->value);
			current->value = ft_strdup(value);
			return ;
		}
		current = current->next;
	}
}

void	update_env_paths(t_env **env_list, char *oldpath, char *newpwd)
{
	t_env	*old;
	t_env	*pwd;

	old = find_env_var(*env_list, "OLDPWD");
	pwd = find_env_var(*env_list, "PWD");
	if (old)
	{
		free(old->value);
		old->value = ft_strdup(oldpath);
	}
	else
		add_env_var(NULL, env_list, "OLDPWD", oldpath);
	if (newpwd && pwd)
	{
		free(pwd->value);
		pwd->value = ft_strdup(newpwd);
	}
}

void	updatepwd(t_env **env_list, char *oldpath)
{
	char	*newpwd;

	newpwd = getcwd(NULL, 0);
	if (!newpwd)
	{
		perror("cd: error retrieving current directory");
		g_exit_status = 1;
		update_env_paths(env_list, oldpath, NULL);
		return ;
	}
	update_env_paths(env_list, oldpath, newpwd);
	free(newpwd);
}

/* void	existing_value(t_data *data, t_env **env_list, char *name, char *value)
{
	t_env	*existing;
	char	*copied_value;

	existing = find_env_var(*env_list, name);
	if (existing)
	{
		if (value)
		{
			free(existing->value);
			existing->value = ft_strdup(value);
			if (!existing->value)
				malloc_failed(data);
		}
	}
	else
	{
		copied_value = NULL;
		if (value)
		{
			copied_value = ft_strdup(value);
			if (!copied_value)
				malloc_failed(data);
		}
		add_env_var(data, env_list, ft_strdup(name), copied_value);

	}
}  */

void	dontexist_value(t_data *data, t_env **env_list, char *name, char *value)
{
	char	*copied_name;
	char	*copied_value;

	copied_name = ft_strdup(name);
	if (!copied_name)
		malloc_failed(data);
	copied_value = NULL;
	if (value)
	{
		copied_value = ft_strdup(value);
		if (!copied_value)
		{
			free(copied_name);
			malloc_failed(data);
		}
	}
	add_env_var(data, env_list, copied_name, copied_value);
	free(copied_name);
	if (copied_value)
		free(copied_value);
}

 void	existing_value(t_data *data, t_env **env_list, char *name, char *value)
{
	t_env	*existing;

	existing = find_env_var(*env_list, name);
	if (existing)
	{
		if (value)
		{
			free(existing->value);
			existing->value = ft_strdup(value);
			if (!existing->value)
				malloc_failed(data);
		}
	}
	else
		dontexist_value(data, env_list, name, value);
}


/* ======= fichier: ./Exec/export.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/20 20:41:49 by aboutale          #+#    #+#             */
/*   Updated: 2025/05/07 00:30:55 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	validate_export_name(char *name)
{
	int	i;

	i = 1;
	if (!name)
		return (0);
	if (!ft_isalpha(name[0]) && name[0] != '_')
		return (0);
	while (name[i])
	{
		if (!ft_isalnum(name[i]) && name[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

char	*extract_name(char *arg)
{
	char	*sign;

	if (arg[0] == '\0')
		return (NULL);
	if (!arg || *arg == '\0')
		return (NULL);
	sign = ft_strchr(arg, '=');
	if (arg[0] == '=')
		return (NULL);
	if (!sign)
		return (ft_strdup(arg));
	return (ft_substr(arg, 0, sign - arg));
}

char	*extract_value(char *arg)
{
	char	*sign;

	if (!arg || *arg == '\0')
		return (NULL);
	sign = ft_strchr(arg, '=');
	if (!sign)
		return (NULL);
	if (*(sign + 1) == '\0')
		return (ft_strdup(""));
	return (ft_strdup(sign + 1));
}

t_env	*copyenvlist(t_data *data, t_env *env_list)
{
	t_env	*newlist;
	t_env	*current;

	newlist = NULL;
	current = env_list;
	while (current)
	{
		add_env_var(data, &newlist, current->name, current->value);
		current = current->next;
	}
	return (newlist);
}

void	built_export(t_data *data, t_env *env_list)
{
	t_env	*sortedlist;
	t_env	*current;

	sortedlist = copyenvlist(data, env_list);
	sort_env(&sortedlist);
	current = sortedlist;
	while (current)
	{
		if (ft_strcmp(current->name, "_") != 0)
		{
			if (current->value == NULL)
				printf("declare -x %s\n", current->name);
			else
				printf("declare -x %s=\"%s\"\n", current->name, current->value);
		}
		current = current->next;
	}
	free_env_list(sortedlist);
}


/* ======= fichier: ./Exec/export3.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export3.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/12 18:24:58 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/16 23:42:22 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	increment_and_free(int *i, char *value, char *name)
{
	free(name);
	free(value);
	(*i)++;
}

int	is_concatenation(char *str)
{
	char	*eq;

	eq = ft_strchr(str, '=');
	if (!eq || eq == str)
		return (0);
	return (*(eq - 1) == '+');
}

int	loop(t_env *current, char *new_value, char *var_name)
{
	char	*joined;

	while (current)
	{
		if (ft_strcmp(current->name, var_name) == 0)
		{
			if (current->value)
				joined = ft_strjoin(current->value, new_value);
			else
				joined = ft_strdup(new_value);
			free(current->value);
			current->value = joined;
			return (1);
		}
		current = current->next;
	}
	return (0);
}

void	ft_concatenation(char *str, t_env **env_list, t_data *data)
{
	char	*equal_sign;
	char	*var_name;
	char	*new_value;
	t_env	*current;

	var_name = NULL;
	new_value = NULL;
	equal_sign = ft_strchr(str, '=');
	if (equal_sign && equal_sign > str && *(equal_sign - 1) == '+')
	{
		var_name = ft_substr(str, 0, equal_sign - str - 1);
		new_value = ft_strdup(equal_sign + 1);
	}
	current = *env_list;
	if (!loop(current, new_value, var_name))
		existing_value(data, env_list, var_name, new_value);
	free(var_name);
	free(new_value);
}

void	built_export2(t_data *data, t_env **env_list, char **args)
{
	int		i;
	char	*name;
	char	*value;

	i = 1;
	while (args[i])
	{
		if (is_concatenation(args[i]))
		{
			ft_concatenation(args[i], env_list, data);
			i++;
			continue ;
		}
		name = extract_name(args[i]);
		value = extract_value(args[i]);
		if (!name || !validate_export_name(name))
		{
			printf("export: `%s': not a valid identifier\n", args[i]);
			g_exit_status = 1;
			increment_and_free(&i, value, name);
			continue ;
		}
		existing_value(data, env_list, name, value);
		increment_and_free(&i, value, name);
	}
}


/* ======= fichier: ./Exec/getpath.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   getpath.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/26 21:43:31 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/16 23:42:22 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

char	*get_absolute_path(char *cmd)
{
	if (cmd[0] == '/' || cmd[0] == '.')
	{
		if (access(cmd, X_OK) == 0)
			return (ft_strdup(cmd));
	}
	return (NULL);
}

char	*find_cmd_path(char *cmd, t_env *env_list)
{
	char	*path;
	char	**token;
	char	*full_path;
	int		i;

	i = 0;
	path = getenvp(env_list, "PATH");
	if (!path)
		return (free(path), NULL);
	token = ft_split(path, ':');
	while (token[i])
	{
		full_path = malloc(ft_strlen(token[i]) + ft_strlen(cmd) + 2);
		if (!full_path)
			break ;
		ft_strcpy(full_path, token[i]);
		ft_strcat(full_path, "/");
		ft_strcat(full_path, cmd);
		if (access(full_path, X_OK) == 0)
			return (free_tab(token), full_path);
		free(full_path);
		i++;
	}
	free_tab(token);
	return (NULL);
}

char	*getpath(char *cmd, t_data *data)
{
	char	*fullpath;

	fullpath = get_absolute_path(cmd);
	if (fullpath)
		return (fullpath);
	fullpath = find_cmd_path(cmd, data->env);
	if (!fullpath)
		g_exit_status = 127;
	return (fullpath);
}


/* ======= fichier: ./Exec/exec2.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec2.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 22:20:48 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/16 23:50:56 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

bool	is_a_directory(char *path, char **args)
{
	struct stat	sb;

	if (!args || !args[0] || args[0][0] == '\0')
	{
		printf("minishell: command not found\n");
		g_exit_status = 127;
		free(path);
		return (true);
	}
	if (stat(path, &sb) == 0 && S_ISDIR(sb.st_mode))
	{
		printf("bash: %s: Is a directory\n", args[0]);
		free(path);
		g_exit_status = 126;
		return (true);
	}
	return (false);
}

void	exec_builtin_redirection(t_data *data)
{
	int	saved_in;
	int	saved_out;

	saved_in = dup(STDIN_FILENO);
	saved_out = dup(STDOUT_FILENO);
	if (data->cmd->fd_in != STDIN_FILENO)
	{
		dup2(data->cmd->fd_in, STDIN_FILENO);
		close(data->cmd->fd_in);
	}
	if (data->cmd->fd_out != STDOUT_FILENO)
	{
		dup2(data->cmd->fd_out, STDOUT_FILENO);
		close(data->cmd->fd_out);
	}
	exec_builtin(data);
	dup2(saved_in, STDIN_FILENO);
	dup2(saved_out, STDOUT_FILENO);
	close(saved_in);
	close(saved_out);
}

void	executecommand(t_data *data)
{
	if (!data || !data->line || !data->env)
		return ;
	if (data->cmd->fd_in == -1 || data->cmd->fd_out == -1)
	{
		g_exit_status = 1;
		return ;
	}
	if (data->cmd->next)
		exec_pipe(data->cmd, data);
	else if (isbuiltin(data))
	{
	 	if (!ft_strcmp(data->cmd->args[0], "exit"))
			builtin_exit(data);
		else 
			exec_builtin_redirection(data);
	}
	else if (!data->cmd->args || !data->cmd->args[0])
	{
	// Ne pas exÃ©cuter, mais si redirection seule, tu crÃ©es le fichier vide
		if (data->cmd->fd_out != STDOUT_FILENO)
		{
			write(data->cmd->fd_out, "", 0);
			close(data->cmd->fd_out);
			data->cmd->fd_out = STDOUT_FILENO;
		}
		if (data->cmd->fd_in != STDIN_FILENO)
		{
			close(data->cmd->fd_in);
			data->cmd->fd_in = STDIN_FILENO;
		}

		return ;
	}
	else if (data->cmd->args && data->cmd->args[0])
		exec_extern_command(data->cmd->args, data->env, data);
	else
	{
	/* 	if (data->cmd->fd_in != STDIN_FILENO)
		{
			close(data->cmd->fd_in);
			data->cmd->fd_in =STDIN_FILENO;
		}
		if (data->cmd->fd_out != STDOUT_FILENO)
		{
			close(data->cmd->fd_out);
			data->cmd->fd_out = STDOUT_FILENO;
		} */
		while(wait(NULL) > 0)
			;
		if (data->cmd->fd_in != STDIN_FILENO)
		{
    		close(data->cmd->fd_in);
   	 		data->cmd->fd_in = STDIN_FILENO;
		}
		if (data->cmd->fd_out != STDOUT_FILENO)
		{
			close(data->cmd->fd_out);
			data->cmd->fd_out = STDOUT_FILENO;
		}
	}
}

t_env	*find_env_var(t_env *env_list, char *name)
{
	while (env_list != NULL)
	{
		if (ft_strcmp(env_list->name, name) == 0)
			return (env_list);
		env_list = env_list->next;
	}
	return (NULL);
}


/* ======= fichier: ./Exec/pipe.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/22 16:20:22 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/19 02:31:50 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	setup_outandin(t_cmd *cmd, int prev_fd, int *pipe_fd)
{
		// STDIN â† prev_fd ou redirection
	 if (cmd->fd_in != STDIN_FILENO)
	{
		dup2(cmd->fd_in, STDIN_FILENO);
		close(cmd->fd_in);
	}
	else if (prev_fd != -1)
	{
		dup2(prev_fd, STDIN_FILENO);
		close(prev_fd);
	}
	// STDOUT â† redirection > result OU pipe
	if (cmd->fd_out != STDOUT_FILENO)
	{
		dup2(cmd->fd_out, STDOUT_FILENO);
		close(cmd->fd_out);
	}
	else if (cmd->next)
	{
		dup2(pipe_fd[1], STDOUT_FILENO);
		close(pipe_fd[1]);
	} 
	// ðŸ”’ Ferme les extrÃ©mitÃ©s inutiles
	if (cmd->next)
		close(pipe_fd[0]);
 	if (cmd->next || cmd->fd_out == STDOUT_FILENO)
		close(pipe_fd[1]);
	if (prev_fd != -1)
		close(prev_fd); 
} 

bool	is_empty_cmd(t_cmd *cmd)
{
	return (!cmd || !cmd->args || !cmd->args[0]);
}


void	exec_command(t_cmd *cmd, t_data *data)
{
	char	*path;

	if (!cmd->args || !cmd->args[0])
		exit(0);
	if (isbuiltin(data))
	{
		exec_builtin(data);
		close_all_fd();
		exit(0);
	}
	path = getpath(cmd->args[0], data);
	if (!path)
	{
		close_all_fd();
		handle_command_error(cmd->args[0], "command not found\n", 127, data);
	}
	reset_signals_to_default();
	if (execve(path, cmd->args, convert_env(data->env)) == -1)
	{
		close_all_fd();
		perror("execve");
	}
	exit(127);
}

void	children(t_cmd *cmd, t_data *data, int prev_fd, int *pipe_fd)
{
	data->cmd = cmd;

	setup_outandin(cmd, prev_fd, pipe_fd);
	if (cmd->fd_in == -1 || cmd->fd_out == -1)
		exit(1);// redirection Ã©chouÃ©e, on quitte proprement
	dprintf(2, "CHILD: cmd = %s\n", cmd->args ? cmd->args[0] : "NULL");	
	exec_command(cmd, data);
}

/* 
void	children(t_cmd *cmd, t_data *data, int prev_fd, int *pipe_fd)
{
	if (!cmd->args || !cmd->args[0])
        exit(0); // juste redirection, pas de commande Ã  exÃ©cuter
	data->cmd = cmd;
 	if (cmd->fd_in == -1 || cmd->fd_out == -1)
		exit(1);// redirection Ã©chouÃ©e, on quitte proprement
	setup_outandin(cmd, prev_fd, pipe_fd);

	exec_command(cmd, data);
} */

void	parent(t_cmd *cmd, int *pipe_fd, int *prev_fd)
{
	if (*prev_fd != -1)
		close(*prev_fd);
	if (cmd->next)
	{
		close(pipe_fd[1]);
		*prev_fd = pipe_fd[0];
	}
/* 	else
	{
		// Pas de commande suivante ou elle est vide
		close(pipe_fd[0]);
		close(pipe_fd[1]);
		*prev_fd = -1;
	}
	dprintf(2, "PARENT: closing pipe_fd: %d %d\n", pipe_fd[0], pipe_fd[1]); */

}

/* bool	is_invalid_command(char *path, char *cmd_name)
{
	if (!cmd_name || cmd_name[0] == '\0')
		return (true); // vide

	if (access(path, F_OK) != 0)
		return (true); // n'existe pas

	if (is_a_directory(path, NULL))
		return (true); // dossier

	if (access(path, X_OK) != 0)
		return (true); // pas exÃ©cutable

	return (false); // tout est ok
} */


bool	has_real_command(t_cmd *cmd)
{
	while (cmd)
	{
		if (cmd->args && cmd->args[0])
			return true;
		cmd = cmd->next;
	}
	return false;
}




void	exec_pipe(t_cmd *cmd, t_data *data)
{
	int		pipe_fd[2];
	pid_t	pid;
	pid_t	last_pid;
	int		prev_fd;
	int		status;
	//char *path;

	prev_fd = -1;
	while (cmd)
 	 {

		//bool next_cmd_valid = cmd->next && !is_empty_cmd(cmd->next);

		if (is_empty_cmd(cmd))
		{
			if (cmd->fd_out != STDOUT_FILENO)
			{
				close(cmd->fd_out);
        		cmd->fd_out = STDOUT_FILENO;
			}
			if (cmd->fd_in != STDIN_FILENO)
			{
				close(cmd->fd_in);
				cmd->fd_in = STDIN_FILENO;
			}
			if (prev_fd != -1)
			{
				close(prev_fd);
				prev_fd = -1;
			}
			cmd = cmd->next;
			continue;
		} 

		if (cmd->next && !is_empty_cmd(cmd->next))
		{
			if (pipe(pipe_fd) == -1)
			{
				perror("pipe");
				exit(1);
			}
		}
		else
		{
			pipe_fd[0] = -1;
   			pipe_fd[1] = -1;
		}
		pid = fork();
		if (pid == -1)
		{
			perror("fork");
			exit(1);
		}
		if (pid == 0)
			children(cmd, data, prev_fd, pipe_fd);
		if (cmd->next == NULL)
			last_pid = pid;
		parent(cmd, pipe_fd, &prev_fd);
		cmd = cmd->next;
	} 

	ignore_sigint();
	bool sigint_printed = false;
	while ((pid = wait(&status)) > 0)
	{
    	if (WIFSIGNALED(status))
    	{
        	int sig = WTERMSIG(status);
        	if (sig == SIGINT && !sigint_printed && pid != last_pid)
        	{
            	write(STDOUT_FILENO, "\n", 1);
            	sigint_printed = true;
        	}
    	}
    if (pid == last_pid && !sigint_printed)
        handle_status_and_print(status);
	else if (pid == last_pid && sigint_printed)
		g_exit_status = 130;
	}
	close_all_fd();
/* 	while ((pid = wait(&status)) > 0)
		g_exit_status = WEXITSTATUS(status);
	close_all_fd();  */
	/*   while (wait(NULL) > 0)
		;
	if (prev_fd != -1)
		close(prev_fd);  */
}


/* ======= fichier: ./Gnl/get_next_line_utils.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aboutale <aboutale@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/13 17:25:33 by aboutale          #+#    #+#             */
/*   Updated: 2024/12/06 16:16:12 by aboutale         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"

size_t	ft_strlen(const char *s)
{
	size_t	i;

	i = 0;
	if (s)
		while (s[i] != '\0')
			i++;
	return (i);
}

char	*ft_strdup(const char *s)
{
	char	*dup;
	int		i;

	i = 0;
	if (!s)
		return (NULL);
	while (s[i])
		i++;
	dup = (char *)malloc(i + 1);
	if (!dup)
		return (NULL);
	i = 0;
	while (s[i])
	{
		dup[i] = s[i];
		i++;
	}
	dup[i] = '\0';
	return (dup);
}

void	*ft_calloc(size_t nmemb, size_t size)
{
	void	*p;
	size_t	i;

	if (size != 0 && (nmemb * size) / size != nmemb)
		return (NULL);
	p = malloc(nmemb * size);
	if (!(p))
		return (NULL);
	i = 0;
	while (i < size * nmemb)
	{
		((char *)p)[i] = '\0';
		i++;
	}
	return (p);
}

/* char	*ft_strjoin(char *s1, char *s2)
{
	char	*joi;
	int		i;
	int		j;

	i = 0;
	j = 0;
	if (!s2 || !s1)
		return (NULL);
	joi = (char *)ft_calloc(sizeof(char), (ft_strlen(s1) + ft_strlen(s2) + 1));
	if (joi == NULL)
		return (NULL);
	while (s1[i])
	{
		joi[i] = s1[i];
		i++;
	}
	while (s2[j])
	{
		joi[i + j] = s2[j];
		j++;
	}
	return (joi);
} */

char	*ft_strchr(const char *s, int c)
{
	int	i;

	i = 0;
	while (s[i])
	{
		if (s[i] == (unsigned char) c)
			return ((char *)&s[i]);
		i++;
	}
	if ((unsigned char)c == '\0')
		return ((char *)&s[i]);
	return (NULL);
}


/* ======= fichier: ./Gnl/get_next_line.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aboutale <aboutale@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/11 17:33:23 by aboutale          #+#    #+#             */
/*   Updated: 2025/03/13 17:48:56 by aboutale         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"

int	readbuffer(int fd, char **buffer)
{
	int		readchar;
	char	*temp ;
	char	*newbuffer;

	temp = malloc(sizeof(char) * BUFFER_SIZE +1);
	if (!temp)
		return (-1);
	readchar = read(fd, temp, BUFFER_SIZE);
	if (readchar < 0)
	{
		free(temp);
		return (readchar);
	}
	temp[readchar] = '\0';
	newbuffer = ft_strjoin(*buffer, temp);
	free(temp);
	if (!newbuffer)
		return (-1);
	free(*buffer);
	*buffer = newbuffer;
	return (readchar);
}

char	*extractline(char *buffer)
{
	int		i;
	int		j;
	char	*line;

	line = NULL;
	i = 0;
	if (!buffer)
		return (NULL);
	while (buffer[i] != '\n' && buffer[i])
		i++;
	if (buffer[i] == '\n')
		i++;
	line = (char *)malloc(sizeof(char) * (i + 1));
	if (!line)
		return (NULL);
	j = 0;
	while (j < i)
	{
		line[j] = buffer[j];
		j++;
	}
	line[j] = '\0';
	return (line);
}

int	refreshbuffer(char **buffer)
{
	int		i;
	char	*newbuffer;

	i = 0;
	while ((*buffer)[i] != '\n' && (*buffer)[i] != '\0')
		i++;
	newbuffer = NULL;
	if ((*buffer)[i] == '\n')
	{
		if (ft_strlen(*buffer) - i > 0)
		{
			newbuffer = ft_strdup(&(*buffer)[i + 1]);
			if (!newbuffer)
				return (-1);
		}
		free(*buffer);
		*buffer = newbuffer;
	}
	else
	{
		free(*buffer);
		*buffer = NULL;
	}
	return (0);
}

int	nextline(int fd, char **buffer, char **line)
{
	int	readchar;

	readchar = readbuffer(fd, buffer);
	while ((readchar > 0))
	{
		if (ft_strchr(*buffer, '\n'))
		{
			*line = extractline(*buffer);
			if (!*line)
				return (-1);
			if (refreshbuffer(buffer) == -1)
				return (-1);
			return (1);
		}
		readchar = readbuffer(fd, buffer);
	}
	if (readchar == 0 && *buffer && **buffer != '\0')
	{
		*line = ft_strdup(*buffer);
		free(*buffer);
		*buffer = NULL;
		return (1);
	}
	free(*line);
	return (0);
}

char	*get_next_line(int fd)
{
	static char	*buffer[1024];
	char		*line;

	line = NULL;
	if (fd < 0 || BUFFER_SIZE <= 0 || fd > 1023)
		return (NULL);
	if (!buffer[fd])
		buffer[fd] = ft_strdup("");
	if (!buffer[fd])
		return (NULL);
	if (*buffer[fd] && ft_strchr(buffer[fd], '\n'))
	{
		line = extractline(buffer[fd]);
		refreshbuffer(&buffer[fd]);
		return (line);
	}
	if (nextline(fd, &buffer[fd], &line) > 0)
		return (line);
	free(buffer[fd]);
	buffer[fd] = NULL;
	return (NULL);
}


/* ======= fichier: ./Libft/ft_util_convert.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_util_convert.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 15:25:28 by mlavry            #+#    #+#             */
/*   Updated: 2024/12/18 14:25:48 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

/* static int	numlen(int n)
{
	int	len;

	len = 1;
	if (n < 0)
		len++;
	while (n / 10 != 0)
	{
		len++;
		n /= 10;
	}
	return (len);
} */

int	u_numlen(unsigned int n)
{
	int	len;

	len = 0;
	while (n != 0)
	{
		len++;
		n /= 10;
	}
	return (len);
}

/* char	*ft_itoa(int n)
{
	unsigned int	num;
	int				len;
	char			*str;

	len = numlen(n);
	str = (char *)malloc(len + 1);
	if (!str)
		return (NULL);
	str [len--] = '\0';
	if (n < 0)
	{
		str [0] = '-';
		num = -n;
	}
	else
		num = n;
	while (num >= 10)
	{
		str [len--] = (num % 10) + '0';
		num /= 10;
	}
	str [len] = num + '0';
	return (str);
} */

char	*ft_uitoa(unsigned int n)
{
	int				len;
	char			*str;

	len = u_numlen(n);
	str = (char *)malloc(len + 1);
	if (!str)
		return (0);
	str [len--] = '\0';
	while (n != 0)
	{
		str [len] = n % 10 + 48;
		n = n / 10;
		len--;
	}
	return (str);
}


/* ======= fichier: ./Libft/ft_isprint.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isprint.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 11:51:33 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/15 12:02:04 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_isprint(int c)
{
	return (c >= 32 && c <= 126);
}

/*int main()
{
	char chars[] = {'A', '0', '1', '*', '\n', 'm'};
    int i;

    for (i = 0; i < 6; i++) {
        if (ft_isprint(chars[i])) {
            printf("Le caractÃ¨re '%c' est imprimable.\n", chars[i]);
        }
		else {
        printf("Le caractÃ¨re '%c' n'est pas imprimable.\n", chars[i]);
        }
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_atoi.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 10:46:15 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/03 00:49:00 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_atoi(const char *nptr)
{
	int	i;
	int	result;
	int	sign;

	i = 0;
	result = 0;
	sign = 0;
	while (nptr[i] == ' ' || (nptr[i] >= 9 && nptr[i] <= 13))
		i++;
	if (nptr[i] == '+' || nptr[i] == '-')
	{
		if (nptr[i] == '-')
			sign++;
		i++;
	}
	while (nptr[i] >= '0' && nptr[i] <= '9')
	{
		result = result * 10 + (nptr[i] - '0');
		i++;
	}
	if (sign % 2 != 0)
		result = -result;
	return (result);
}

/* int	main(void)
{
	char str1[] = " -1234ab567";
	char str2[] = "  569999999999999+7b8";
	char *str3 = "0";

	int num1 = ft_atoi(str1);
	int num2 = ft_atoi(str2);
	int num3 = ft_atoi(str3);
	int num4 = ft_atoi("00001");
	int num5 = ft_atoi("214748364");

	printf("num1 = %d\n", num1);
	printf("num2 = %d\n", num2);
	printf("num3 = %d\n", num3);
	printf("num4 = %d\n", num4);
	printf("num5 = %d\n", num5);

	return (0);
} */


/* ======= fichier: ./Libft/ft_bzero.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bzero.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 15:42:21 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/02 16:36:42 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

void	ft_bzero(void *s, size_t n)
{
	unsigned char	*ptr;

	if (!s && n > 0)
		return ;
	ptr = (unsigned char *)s;
	while (n)
	{
		*ptr = 0;
		n--;
		ptr++;
	}
}

/*int main (void)
{
	char buffer[5] = "1234";
	int i = 0;
	ft_bzero(buffer, sizeof(buffer));
	while (i < 5)
	{
		printf("%d", buffer[i]);
		i++;
	}
	return (0);
}*/


/* ======= fichier: ./Libft/ft_calloc.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 17:41:41 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/21 14:38:56 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

void	*ft_calloc(size_t n, size_t size)
{
	void			*ptr;
	size_t			total_size;
	unsigned char	*final;

	total_size = n * size;
	if (n != 0 && total_size / n != size)
		return (0);
	ptr = malloc(total_size);
	if (ptr == 0)
		return (0);
	final = (unsigned char *)ptr;
	while (total_size)
	{
		*final = 0;
		total_size--;
		final++;
	}
	return (ptr);
}

/*int main(void)
{
    int *arr;
    size_t n = 5;
    size_t size = sizeof(int);

    arr = (int *)ft_calloc(n, size);

    if (arr == NULL)
    {
        printf("Allocation Ã©chouÃ©e\n");
        return (1);
    }

    printf("Contenu du tableau allouÃ© et initialisÃ© Ã  zÃ©ro :\n");
    for (size_t i = 0; i < n; i++)
    {
        printf("arr[%zu] = %d\n", i, arr[i]);
    }

    free(arr);

    return 0;
}*/


/* ======= fichier: ./Libft/ft_isalnum.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalnum.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 10:50:14 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/15 11:08:12 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_isalnum(int c)
{
	return ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
		|| (c >= '0' && c <= '9'));
}

/*int main()
{
    char chars[] = {'A', 'b', '1', '*', 'Z', ' '};
    int i;

    for (i = 0; i < 6; i++) {
        if (ft_isalnum(chars[i])) {
            printf("Le caractÃ¨re '%c' est alphanumerique.\n", chars[i]);
        }
		else {
        printf("Le caractÃ¨re '%c' n'est pas alphanumerique.\n", chars[i]);
        }
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_isalpha.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalpha.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 10:25:50 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/15 10:46:23 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_isalpha(int c)
{
	return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));
}

/*int main()
{
    char chars[] = {'A', 'b', '1', '*', 'Z', 'm'};
    int i;

    for (i = 0; i < 6; i++) {
        if (ft_isalpha(chars[i])) {
            printf("Le caractÃ¨re '%c' est une lettre alphabÃ©tique.\n", chars[i]);
        }
		else {
        printf("Le caractÃ¨re '%c' n'est pas alphabÃ©tique.\n", chars[i]);
        }
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_isascii.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isascii.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 11:21:25 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/15 11:50:51 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_isascii(int c)
{
	return (c >= 0 && c <= 127);
}

/*int main()
{
    char chars[] = {'126', 'b', '1', '*', '132', '-4'};
    int i;

    for (i = 0; i < 6; i++) {
        if (ft_isascii(chars[i])) {
            printf("Le caractÃ¨re '%c' est un caractere ascii.\n", chars[i]);
        }
		else {
        printf("Le caractÃ¨re '%c' n'est pas un caractere ascii.\n", chars[i]);
        }
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_isdigit.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isdigit.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 10:39:28 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/15 10:50:20 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_isdigit(int c)
{
	return (c >= '0' && c <= '9');
}

/*int main()
{
    char chars[] = {'A', '0', '1', '*', '9', 'm'};
    int i;

    for (i = 0; i < 6; i++) {
        if (ft_isdigit(chars[i])) {
            printf("Le caractÃ¨re '%c' est un chiffre.\n", chars[i]);
        }
		else {
        printf("Le caractÃ¨re '%c' n'est pas un chiffre.\n", chars[i]);
        }
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_toupper.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_toupper.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 10:43:00 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/17 11:05:18 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_toupper(int c)
{
	if (c >= 'a' && c <= 'z')
		c -= 32;
	return (c);
}

/*int main(void)
{
    char test_chars[] = {'a', 'z', 'A', 'Z', '1', '!', 'm'};
    unsigned int i;

    printf("Testing ft_toupper function:\n\n");

    for (i = 0; i < sizeof(test_chars); i++)
    {
        char original = test_chars[i];
        char upper = ft_toupper(original);
        printf("Original: %c | Upper: %c\n", original, upper);
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_strncmp.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strncmp.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 17:18:47 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:26:14 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	while (n && *s1 && (*s1 == *s2))
	{
		s1++;
		s2++;
		n--;
	}
	if (n == 0)
		return (0);
	return ((unsigned char)(*s1) - (unsigned char)(*s2));
}

/*int main (void)
{
	char str1[] = "AZDe";
	char str2[] = "ABDe";

	int result = ft_strncmp(str1, str2, sizeof (str1));
	printf ("La comparaison de %s et de %s donne %d", str1, str2, result);
}*/


/* ======= fichier: ./Libft/ft_strnstr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strnstr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 10:16:45 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:26:24 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

char	*ft_strnstr(const char *big,	const char *little, size_t len)
{
	size_t	i;
	size_t	j;

	i = 0;
	if (*little == '\0')
		return ((char *)(big));
	while (big[i] != '\0' && i < len)
	{
		j = 0;
		while (big[j + i] == little[j] && (i + j) < len)
		{
			if (little [j + 1] == '\0')
				return ((char *)(&big[i]));
			j++;
		}
		i++;
	}
	return (0);
}

/*int	main(void)
{
	char str[] = "Bonjour tout le monde";
	char to_find[] = "toit";

	char *result = ft_strnstr(str, to_find, sizeof (str));
	if (result != 0)
		printf("Resultat :%s\n", result);
	else
		printf("Erreur.\n");
	return (0);
}*/


/* ======= fichier: ./Libft/ft_strrchr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strrchr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 11:47:37 by mlavry            #+#    #+#             */
/*   Updated: 2025/01/06 18:11:56 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

char	*ft_strrchr(const char *s, int c)
{
	char	*temp;

	temp = 0;
	while (*s)
	{
		if (*s == (unsigned char)c)
			temp = (char *)s;
		s++;
	}
	if ((unsigned char)c == '\0')
		return ((char *)s);
	return (temp);
}

/* int main(void)
{
    char str[] = "Hello, world!";
    char *result;

    result = ft_strrchr(str, 'o');
    if (result)
        printf("Last occurrence of 'o' found at: %s\n", result);
    else
        printf("'o' not found\n");

    return 0;
} */


/* ======= fichier: ./Libft/ft_strtrim.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strtrim.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 12:41:14 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/25 13:00:39 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static int	ft_is_in_set(char c, const char *set)
{
	while (*set)
	{
		if (c == *set)
			return (1);
		set++;
	}
	return (0);
}

char	*ft_strtrim(char const *s1, char const *set)
{
	int		start;
	int		end;
	char	*trimmed_str;
	int		i;

	start = 0;
	i = 0;
	if (!s1 || !set)
		return (NULL);
	while (s1[start] && ft_is_in_set(s1[start], set))
		start++;
	end = start;
	while (s1[end])
		end++;
	end--;
	while (end >= start && ft_is_in_set(s1[end], set))
		end--;
	trimmed_str = malloc(end - start + 2);
	if (!trimmed_str)
		return (NULL);
	while (start <= end)
		trimmed_str[i++] = s1[start++];
	trimmed_str[i] = '\0';
	return (trimmed_str);
}


/* ======= fichier: ./Libft/ft_substr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_substr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 17:21:34 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 18:19:47 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_substr(char const *s, unsigned int start, size_t len)
{
	char	*sub;
	size_t	s_len;

	if (!s)
		return (NULL);
	s_len = ft_strlen(s);
	if (start >= s_len)
		return (ft_strdup(""));
	if (start + len > s_len)
		len = s_len - start;
	sub = (char *)malloc(len + 1);
	if (!sub)
		return (NULL);
	ft_strlcpy(sub, s + start, len + 1);
	return (sub);
}

/*#include <stdio.h>

int main() {
    const char *original = "Hello, World!";
    char *substring = ft_substr(original, 7, 5); // Extrait "World"

    if (substring) {
        printf("Sous-chaÃ®ne : %s\n", substring);
        free(substring); // N'oublie pas de libÃ©rer la mÃ©moire
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_tolower.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tolower.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 11:13:20 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/17 11:17:45 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_tolower(int c)
{
	if (c >= 'A' && c <= 'Z')
		c += 32;
	return (c);
}

/*int main(void)
{
    char test_chars[] = {'a', 'z', 'A', 'Z', '1', '!', 'm'};
    unsigned int i;

    printf("Testing ft_tolower function:\n\n");

    for (i = 0; i < sizeof(test_chars); i++)
    {
        char original = test_chars[i];
        char lower = ft_tolower(original);
        printf("Original: %c | Lower: %c\n", original, lower);
    }

    return (0);
}*/


/* ======= fichier: ./Libft/ft_strmapi.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strmapi.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 17:01:55 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/04 17:30:00 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
{
	char			*new_str;
	unsigned int	i;

	if (!s || !f)
		return (NULL);
	new_str = (char *)malloc((ft_strlen(s) + 1) * sizeof(char));
	if (!new_str)
		return (NULL);
	i = 0;
	while (s[i])
	{
		new_str[i] = f(i, s[i]);
		i++;
	}
	new_str[i] = '\0';
	return (new_str);
}


/* ======= fichier: ./Libft/ft_strlen.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlen.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 14:13:34 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:25:57 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

size_t	ft_strlen(const char *s)
{
	int	i;

	i = 0;
	while (s[i] != '\0')
	{
		i++;
	}
	return (i);
}

/*int main(void)
{
	char phrase[] = "Boji";
	int result = ft_strlen(phrase);
	printf("La chaine comporte %d caracteres.\n", result);
}*/


/* ======= fichier: ./Libft/ft_putnbr_fd.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 18:28:34 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/04 18:35:52 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putnbr_fd(int n, int fd)
{
	if (n == -2147483648)
	{
		write(fd, "-2147483648", 11);
		return ;
	}
	if (n < 0)
	{
		ft_putchar_fd('-', fd);
		n = -n;
	}
	if (n >= 10)
	{
		ft_putnbr_fd(n / 10, fd);
	}
	ft_putchar_fd(n % 10 + '0', fd);
}


/* ======= fichier: ./Libft/ft_putstr_fd.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 18:18:57 by mlavry            #+#    #+#             */
/*   Updated: 2025/03/18 18:31:40 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putstr_fd(char *s, int fd)
{
	write(fd, s, ft_strlen(s));
}


/* ======= fichier: ./Libft/ft_split.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 13:04:43 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/05 16:49:38 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static char	**free_array(char **ptr, int i)
{
	while (i > 0)
	{
		i--;
		free(ptr[i]);
	}
	free(ptr);
	return (0);
}

static int	ft_count_words(char const *str, char c)
{
	int	i;
	int	count;

	i = 0;
	count = 0;
	while (str[i] != '\0')
	{
		if (str[i] == c)
			i++;
		else
		{
			count++;
			while (str[i] && str[i] != c)
				i++;
		}
	}
	return (count);
}

static char	*ft_putword(char *word, char const *s, int i, int word_len)
{
	int	j;

	j = 0;
	while (word_len > 0)
	{
		word[j] = s[i - word_len];
		j++;
		word_len--;
	}
	word[j] = '\0';
	return (word);
}

static char	**ft_split_words(char const *s, char c, char **s2, int num_words)
{
	int	i;
	int	word;
	int	word_len;

	i = 0;
	word = 0;
	while (word < num_words)
	{
		while (s[i] && s[i] == c)
			i++;
		word_len = 0;
		while (s[i + word_len] && s[i + word_len] != c)
			word_len++;
		s2[word] = (char *)malloc(sizeof(char) * (word_len + 1));
		if (!s2[word])
			return (free_array(s2, word));
		ft_putword(s2[word], s, i + word_len, word_len);
		i += word_len;
		word++;
	}
	s2[word] = 0;
	return (s2);
}

char	**ft_split(char const *s, char c)
{
	char			**s2;
	unsigned int	num_words;

	if (!s)
		return (0);
	num_words = ft_count_words(s, c);
	s2 = (char **)malloc(sizeof(char *) * (num_words + 1));
	if (!s2)
		return (0);
	return (ft_split_words(s, c, s2, num_words));
}


/* ======= fichier: ./Libft/ft_strchr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 11:19:53 by mlavry            #+#    #+#             */
/*   Updated: 2025/01/06 18:34:30 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

char	*ft_strchr(const char *s, int c)
{
	while (*s)
	{
		if (*s == (unsigned char)c)
			return ((char *)s);
		s++;
	}
	if ((unsigned char)c == '\0')
		return ((char *)s);
	return (0);
}

/* int main(void)
{
    char str[] = "Hello, world!";
    char *result;

    result = ft_strchr(str, 'o');
    if (result)
        printf("First occurrence of 'o' found at: %s\n", result);
    else
        printf("'o' not found\n");

    return 0;
} */


/* ======= fichier: ./Libft/ft_strdup.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 18:24:22 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/02 16:56:09 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

char	*ft_strdup(const char *s)
{
	char	*dest;
	int		i;
	int		len;

	len = 0;
	if (!s)
		return (NULL);
	while (s[len])
		len++;
	dest = (char *)malloc((len + 1) * sizeof(char));
	if (!dest)
		return (0);
	i = 0;
	while (i < len)
	{
		dest[i] = s[i];
		i++;
	}
	dest[i] = '\0';
	return (dest);
}

/*int main(void)
{
    char *original = "Bonjour";
    char *copie = ft_strdup(original);

    if (copie != NULL) {
        printf("Copie : %s\n", copie);
        free(copie);
    } else {
        printf("Ã‰chec de la duplication de la chaÃ®ne.\n");
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_striteri.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_striteri.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 17:34:42 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/04 18:07:21 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_striteri(char *s, void (*f)(unsigned int, char*))
{
	unsigned int	i;

	if (!s || !f)
		return ;
	i = 0;
	while (s[i])
	{
		f(i, &s[i]);
		i++;
	}
}


/* ======= fichier: ./Libft/ft_strjoin.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 18:26:06 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/21 15:50:45 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strjoin(char const *s1, char const *s2)
{
	char	*result;
	char	*start;
	size_t	len1;
	size_t	len2;

	if (!s1 || !s2)
		return (NULL);
	len1 = 0;
	while (s1[len1])
		len1++;
	len2 = 0;
	while (s2[len2])
		len2++;
	result = (char *)malloc(len1 + len2 + 1);
	if (!result)
		return (NULL);
	start = result;
	while (*s1)
		*result++ = *s1++;
	while (*s2)
		*result++ = *s2++;
	*result = '\0';
	return (start);
}

/*#include <stdio.h>

int main() {
    const char *str1 = "Hello, ";
    const char *str2 = "world!";
    char *result = ft_strjoin(str1, str2);

    if (result) {
        printf("%s\n", result); // Affiche "Hello, world!"
        free(result); // N'oublie pas de libÃ©rer la mÃ©moire allouÃ©e
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_strlcat.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcat.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 17:37:09 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:25:28 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

size_t	ft_strlcat(char *dst, const char *src, size_t size)
{
	size_t	i;
	size_t	dst_len;
	size_t	src_len;

	dst_len = 0;
	src_len = 0;
	while (dst[dst_len] != '\0' && dst_len < size)
		dst_len++;
	while (src[src_len] != '\0')
		src_len++;
	if (size <= dst_len)
		return (size + src_len);
	i = 0;
	while (src[i] != '\0' && dst_len + i < size - 1)
	{
		dst[dst_len + i] = src[i];
		i++;
	}
	dst[dst_len + i] = '\0';
	return (dst_len + src_len);
}

/*int main (void)
{
	char dst[50] = "Bonjour";
	char src[] = " ou pas";
	size_t result = ft_strlcat(dst, src, 16);
	printf("Resultat : %zu\n", result);
	printf("Chaine : %s\n", dst);
	return (0);
}*/


/* ======= fichier: ./Libft/ft_strlcpy.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcpy.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 12:35:18 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:25:43 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

size_t	ft_strlcpy(char *dst, const char *src, size_t size)
{
	size_t	i;
	size_t	len;

	i = 0;
	len = 0;
	while (src[len] != '\0')
	{
		len ++;
	}
	if (size > 0)
	{
		while (i < size - 1 && src[i] != '\0')
		{
			dst[i] = src[i];
			i++;
		}
		dst[i] = '\0';
	}
	return (len);
}

/*int main (void)
{
	char src[] = "AAAABC !";
	char dest[20];
	size_t	result = ft_strlcpy(dest, src, sizeof src);
	printf("Source : %s\n", src);
	printf("Dest : %s\n", dest);
	printf("Resultat : %zu\n", result);
}*/


/* ======= fichier: ./Libft/ft_memchr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 17:35:36 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:24:01 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

void	*ft_memchr(const void *s, int c, size_t n)
{
	const unsigned char	*ptr;
	size_t				i;

	ptr = (const unsigned char *) s;
	i = 0;
	while (i < n)
	{
		if (ptr[i] == (unsigned char) c)
		{
			return ((void *)(ptr + i));
		}
		i++;
	}
	return (0);
}

/*int	main(void)
{
	char	buffer[20] = "Bonjour";
	char	*result;

	result = ft_memchr(buffer, '5', sizeof(buffer) - 1);
	if (result != NULL)
		printf("Carac trouvÃ© Ã  l'adresse : %p, rest : %s\n", result, result);
	else
		printf("CaractÃ¨re non trouvÃ©.\n");
	return (0);
}*/


/* ======= fichier: ./Libft/ft_memcmp.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 09:55:30 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 15:58:01 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

int	ft_memcmp(const void *s1, const void *s2, size_t n)
{
	const unsigned char	*str1;
	const unsigned char	*str2;

	str1 = (const unsigned char *) s1;
	str2 = (const unsigned char *) s2;
	while (n)
	{
		if (*str1 != *str2)
			return (*str1 - *str2);
		str1++;
		str2++;
		n--;
	}
	return (0);
}

/*int main (void)
{
	char str1[] = "AZDe";
	char str2[] = "ABDe";

	int result = ft_memcmp(str1, str2, sizeof (str1));
	printf ("La comparaison de %s et de %s donne %d", str1, str2, result);
}*/


/* ======= fichier: ./Libft/ft_memcpy.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcpy.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 16:25:30 by mlavry            #+#    #+#             */
/*   Updated: 2025/05/28 14:35:00 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

void	*ft_memcpy(void *dest, const void *src, size_t n)
{
	unsigned char		*d;
	const unsigned char	*s;

	d = (unsigned char *)dest;
	s = (const unsigned char *)src;
	while (n--)
		*d++ = *s++;
	return (dest);
}

/*int main (void)
{
	char src[] = "Bonjour5646546468";
	char dest[50];

	ft_memcpy(dest, src, sizeof (src) - 1);
	dest[sizeof (src) - 1] = '\0';
	printf("Tableau de dest : %s\n", dest);
	return (0);
}*/


/* ======= fichier: ./Libft/ft_memmove.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memmove.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 12:12:40 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:24:48 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

void	*ft_memmove(void *dest, const void *src, size_t n)
{
	unsigned char		*d;
	const unsigned char	*s;
	size_t				i;

	d = (unsigned char *) dest;
	s = (const unsigned char *) src;
	if (d > s)
	{
		while (n > 0)
		{
			n--;
			d[n] = s[n];
		}
	}
	if (d < s)
	{
		i = 0;
		while (i < n)
		{
			d[i] = s[i];
			i++;
		}
	}
	return (dest);
}

/*int main (void)
{
	char src[] = "Salut !";
	char dest[50];

	ft_memmove(dest, src, sizeof (src) - 1);
	dest[sizeof (src) - 1] = '\0';
	printf ("Tableau de dest : %s\n", dest);
	return (0);
}*/


/* ======= fichier: ./Libft/ft_memset.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 14:41:09 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:25:02 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

void	*ft_memset(void *s, int c, size_t n)
{
	unsigned char	*ptr;

	ptr = (unsigned char *) s;
	while (n)
	{
		*ptr = (unsigned char) c;
		n--;
		ptr++;
	}
	return (s);
}

/*int	main(void)
{
	char	buffer[20];

	ft_memset(buffer, '0', sizeof (buffer) - 1);
	buffer[19] = '\0';
	printf("Tableau cree : %s\n", buffer);
	return (0);
}*/


/* ======= fichier: ./Libft/ft_printf.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/12 14:49:15 by mlavry            #+#    #+#             */
/*   Updated: 2024/12/18 14:14:57 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_printchar(int c)
{
	write(1, &c, 1);
	return (1);
}

int	ft_printpercent(void)
{
	write(1, "%", 1);
	return (1);
}

int	ft_format(va_list args, const char format)
{
	int	printlen;

	printlen = 0;
	if (format == 'c')
		printlen += ft_printchar(va_arg(args, int));
	else if (format == 's')
		printlen += ft_printstr(va_arg(args, char *));
	else if (format == 'p')
		printlen += ft_printptr(va_arg(args, unsigned long));
	else if (format == 'd')
		printlen += ft_printnbr(va_arg(args, int));
	else if (format == 'i')
		printlen += ft_printnbr(va_arg(args, int));
	else if (format == 'u')
		printlen += ft_uprintnbr(va_arg(args, unsigned int));
	else if (format == 'x' || format == 'X')
		printlen += ft_print_hex(va_arg(args, unsigned int), format);
	else if (format == '%')
		printlen += ft_printpercent();
	return (printlen);
}

int	ft_printf(const char *str, ...)
{
	va_list	args;
	int		i;
	int		printlen;

	i = 0;
	printlen = 0;
	va_start(args, str);
	while (str[i])
	{
		if (str[i] == '%')
		{
			printlen += ft_format(args, str[i + 1]);
			i++;
		}
		else
			printlen += ft_printchar(str[i]);
		i++;
	}
	va_end(args);
	return (printlen);
}

/* #include <stdio.h>

int main()
{
	int ptr;

	ptr = 1;

	printf("%%\n");
	ft_printf("%%\n");


} */


/* ======= fichier: ./Libft/ft_printhexa.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printhexa.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/13 18:04:24 by mlavry            #+#    #+#             */
/*   Updated: 2024/12/18 14:15:22 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_hex_len(unsigned int num)
{
	int	len;

	len = 0;
	while (num != 0)
	{
		len++;
		num = num / 16;
	}
	return (len);
}

void	ft_put_hex(unsigned int num, const char format)
{
	if (num >= 16)
	{
		ft_put_hex(num / 16, format);
		ft_put_hex(num % 16, format);
	}
	else
	{
		if (num <= 9)
			ft_putchar(num + '0');
		else
		{
			if (format == 'x')
				ft_putchar(num - 10 + 'a');
			if (format == 'X')
				ft_putchar(num - 10 + 'A');
		}
	}
}

int	ft_print_hex(unsigned int num, const char format)
{
	if (num == 0)
		return (write(1, "0", 1));
	else
		ft_put_hex(num, format);
	return (ft_hex_len(num));
}


/* ======= fichier: ./Libft/ft_printnbr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printnbr.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/20 13:59:06 by mlavry            #+#    #+#             */
/*   Updated: 2024/12/18 14:15:33 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_printnbr(int n)
{
	int		len;
	char	*num;

	len = 0;
	num = ft_itoa(n);
	len = ft_printstr(num);
	free (num);
	return (len);
}

int	ft_uprintnbr(unsigned int n)
{
	int		len;
	char	*num;

	len = 0;
	if (n == 0)
		len += write(1, "0", 1);
	else
	{
		num = ft_uitoa(n);
		len += ft_printstr(num);
		free (num);
	}
	return (len);
}


/* ======= fichier: ./Libft/ft_printptr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printptr.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/13 16:08:26 by mlavry            #+#    #+#             */
/*   Updated: 2024/12/18 14:15:51 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putchar(char c)
{
	write (1, &c, 1);
}

int	ft_ptr_len(unsigned long num)
{
	int	len;

	len = 0;
	if (num == 0)
		return (1);
	while (num != 0)
	{
		len++;
		num = num / 16;
	}
	return (len);
}

void	ft_put_ptr(unsigned long num)
{
	if (num >= 16)
	{
		ft_put_ptr(num / 16);
		ft_put_ptr(num % 16);
	}
	else
	{
		if (num <= 9)
			ft_putchar(num + '0');
		else
			ft_putchar(num - 10 + 'a');
	}
}

int	ft_printptr(unsigned long ptr)
{
	int	printlen;

	printlen = 0;
	if (ptr == 0)
		printlen += write(1, "(nil)", 5);
	else
	{
		printlen += write(1, "0x", 2);
		ft_put_ptr(ptr);
		printlen += ft_ptr_len(ptr);
	}
	return (printlen);
}


/* ======= fichier: ./Libft/ft_printstr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printstr.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 18:18:57 by mlavry            #+#    #+#             */
/*   Updated: 2025/03/19 18:24:29 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_printstr(char *s)
{
	int	i;

	i = 0;
	if (!s)
	{
		ft_putstr_fd("(null)", 1);
		return (6);
	}
	while (s[i])
	{
		write (1, &s[i], 1);
		i++;
	}
	return (i);
}


/* ======= fichier: ./Libft/ft_putchar_fd.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 18:09:35 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/04 18:15:29 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putchar_fd(char c, int fd)
{
	write(fd, &c, 1);
}


/* ======= fichier: ./Libft/ft_putendl_fd.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 18:24:29 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/04 18:27:06 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putendl_fd(char *s, int fd)
{
	while (*s != '\0')
	{
		write(fd, s, 1);
		s++;
	}
	write(fd, "\n", 1);
}


/* ======= fichier: ./Libft/ft_lstnew_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 17:37:43 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/05 17:48:53 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstnew(void *content)
{
	t_list	*new_elem;

	new_elem = (t_list *)malloc(sizeof(t_list));
	if (!new_elem)
		return (NULL);
	new_elem->content = content;
	new_elem->next = NULL;
	return (new_elem);
}


/* ======= fichier: ./Libft/ft_lstsize_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstsize_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 18:19:35 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/05 18:24:56 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_lstsize(t_list *lst)
{
	int	count;

	count = 0;
	while (lst != NULL)
	{
		count++;
		lst = lst->next;
	}
	return (count);
}


/* ======= fichier: ./Libft/ft_lstlast_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstlast_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 18:29:01 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/05 18:36:30 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstlast(t_list *lst)
{
	if (!lst)
		return (NULL);
	while (lst->next != NULL)
	{
		lst = lst->next;
	}
	return (lst);
}


/* ======= fichier: ./Libft/ft_lstmap_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstmap_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 12:11:52 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/06 13:18:37 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))
{
	t_list	*new_lst;
	t_list	*new_node;
	void	*content;

	if (!lst || !f)
		return (NULL);
	new_lst = NULL;
	while (lst)
	{
		content = f(lst->content);
		new_node = ft_lstnew(content);
		if (!new_node)
		{
			if (content)
				del (content);
			ft_lstclear(&new_lst, del);
			return (NULL);
		}
		ft_lstadd_back(&new_lst, new_node);
		lst = lst->next;
	}
	return (new_lst);
}


/* ======= fichier: ./Libft/ft_itoa.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 15:25:28 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/04 16:57:21 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static int	numlen(int n)
{
	int	len;

	len = 1;
	if (n < 0)
		len++;
	while (n / 10 != 0)
	{
		len++;
		n /= 10;
	}
	return (len);
}

char	*ft_itoa(int n)
{
	unsigned int	num;
	int				len;
	char			*str;

	len = numlen(n);
	str = (char *)malloc(len + 1);
	if (!str)
		return (NULL);
	str [len--] = '\0';
	if (n < 0)
	{
		str [0] = '-';
		num = -n;
	}
	else
		num = n;
	while (num >= 10)
	{
		str [len--] = (num % 10) + '0';
		num /= 10;
	}
	str [len] = num + '0';
	return (str);
}


/* ======= fichier: ./Libft/ft_lstadd_back_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_back_bonus.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 18:42:48 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/05 19:11:14 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstadd_back(t_list **lst, t_list *new)
{
	t_list	*current;

	if (!lst || !new)
		return ;
	if (!*lst)
	{
		*lst = new;
		return ;
	}
	current = *lst;
	while (current->next != NULL)
	{
		current = current->next;
	}
	current->next = new;
}


/* ======= fichier: ./Libft/ft_lstadd_front_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_front_bonus.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 17:59:08 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/05 18:16:51 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstadd_front(t_list **lst, t_list *new)
{
	if (!new)
		return ;
	new->next = *lst;
	*lst = new;
}


/* ======= fichier: ./Libft/ft_lstclear_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstclear_bonus.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 11:33:19 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/06 11:56:03 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstclear(t_list **lst, void (*del)(void *))
{
	t_list	*next;

	if (!lst || !del)
		return ;
	while (*lst)
	{
		next = (*lst)->next;
		del((*lst)->content);
		free(*lst);
		*lst = next;
	}
	*lst = NULL;
}


/* ======= fichier: ./Libft/ft_lstdelone_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstdelone_bonus.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 11:22:41 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/06 11:29:32 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstdelone(t_list *lst, void (*del)(void *))
{
	if (!lst || !del)
		return ;
	del (lst->content);
	free (lst);
}


/* ======= fichier: ./Libft/ft_lstiter_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstiter_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 12:02:41 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/06 12:08:35 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstiter(t_list *lst, void (*f)(void *))
{
	if (!lst || !f)
		return ;
	while (lst)
	{
		f (lst->content);
		lst = lst->next;
	}
}


/* ======= fichier: ./Parsing/check_quote.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_quote.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/31 21:21:34 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/16 23:54:47 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	quote_choice(bool *sq, bool *dq, char c)
{
	if ((c == '\'' || c == '"') && !*sq && !*dq)
	{
		if (c == '\'' && !*dq)
			*sq = true;
		if (c == '"' && !*sq)
			*dq = true;
	}
	else if (c == '\'' || c == '"')
	{
		if (c == '\'' && !*dq)
			*sq = false;
		if (c == '"' && !*sq)
			*dq = false;
	}
}

int	open_quote(char *line)
{
	bool	sq;
	bool	dq;
	int		i;

	sq = false;
	dq = false;
	i = 0;
	while (line[i])
	{
		quote_choice(&sq, &dq, line[i]);
		i++;
	}
	if (sq || dq)
	{
		g_exit_status = 2;
		ft_putstr_fd("open quote\n", 2);
		return (1);
	}
	return (0);
}

int	is_quoted(char c)
{
	if (c == '\'')
		return (1);
	if (c == '"')
		return (2);
	return (0);
}

/* void	stock_and_delete_quote(t_token *token)
{
	int		len;
	char	*tmp;

	len = (int)ft_strlen(token->str);
	if (!token || !token->str || len < 2)
		return ;
	if (token->str[0] == '\'' && token->str[len - 1] == '\'')
	{
		token->sq = true;
		tmp = ft_substr(token->str, 1, len - 2);
		if (!tmp)
			return ;
		free(token->str);
		token->str = tmp;
	}
	else if (token->str[0] == '"' && token->str[len - 1] == '"')
	{
		token->dq = true;
		tmp = ft_substr(token->str, 1, len - 2);
		if (!tmp)
			return ;
		free(token->str);
		token->str = tmp;
	}
} */


/* ======= fichier: ./Parsing/expand.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 21:50:04 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/16 23:58:15 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	dollar_exit(char **src, char **res, int *len_buf)
{
	char	*nbr;

	nbr = ft_itoa(g_exit_status);
	if (!nbr)
		return (0);
	if (!str_append(res, len_buf, nbr))
	{
		free(nbr);
		return (0);
	}
	free(nbr);
	*src += 2;
	return (1);
}

int	dollar_var(t_data *data, char **src, char **res, int *len_buf)
{
	size_t	i;
	char	*key;
	char	*value;

	i = 1;
	while ((*src)[i] && (ft_isalnum((*src)[i]) || (*src)[i] == '_'))
		i++;
	if (i <= 1)
		return (0);
	key = ft_substr(*src + 1, 0, i - 1);
	if (!key)
		malloc_failed(data);
	value = getenvp(data->env, key);
	free(key);
	if (value && !str_append(res, len_buf, value))
		malloc_failed(data);
	*src += i;
	return (1);
}

void	check_dollars(t_data *data, char **src, char **res, int *len_buf)
{
	if ((*src)[1] == '?')
	{
		if (!dollar_exit(src, res, len_buf))
			malloc_failed(data);
		return ;
	}
	if (dollar_var(data, src, res, len_buf))
		return ;
	if (!char_append(res, len_buf, *(*src)))
		malloc_failed(data);
	(*src)++;
}

static bool is_shell_delim(char c)
{
    return (c == '|' || c == '&' || c == ';' ||
            c == '(' || c == ')' || c == '<' || c == '>');
}

static bool  is_in_heredoc_delim(char *cur, char *line_start)
{
    char *p = cur;

    while (p > line_start &&
           !is_space(*(p - 1)) &&
           !is_shell_delim(*(p - 1)))
        --p;
    while (p > line_start && is_space(*(p - 1)))
        --p;
    if (p - line_start >= 2 &&
        *(p - 1) == '<' && *(p - 2) == '<')
        return true;

    if (p - line_start >= 3 &&
        *(p - 1) == '-' &&
        *(p - 2) == '<' && *(p - 3) == '<')
        return true;
    return false;
}

/* retourne 1 si on NE doit PAS expander  */
int  check_quote_dollars(char **res, int *len_buf, char **src, t_data *data)
{
    /* a) le $ est dans le mot-dÃ©limiteur here-doc -------------- */
    if (is_in_heredoc_delim(*src, data->line))
    {
		if (!char_append(res, len_buf, *(*src)))
			malloc_failed(data);
        (*src)++;          /* on garde le caractÃ¨re tel quel      */
        return 1;
    }

    /* b) juste aprÃ¨s un guillemet ------------------------------ */
    if (is_quoted((*src)[1]))
    {
        (*src)++;
        return 1;
    }

    /* c) cas $<digit> ----------------------------------------- */
    if (ft_isdigit((*src)[1]))
    {
        (*src) += 2;
        return 1;
    }
    return 0;              /* expansion normale sinon             */
}

void	replace_dollars(t_data *data)
{
	char	*src;
	char	*res;
	int		len_buf;
	bool	sq;
	bool	dq;

	src = data->line;
	res = ft_strdup("");
	if (!res)
		malloc_failed(data);
	len_buf = 0;
	sq = false;
	dq = false;
	while (*src)
	{
		quote_choice(&sq, &dq, *src);
		if (*src == '$' && !dq && !sq)
		{
			if (check_quote_dollars(&res, &len_buf, &src, data))
				continue ;
		}
		if (*src == '$' && !sq)
		{
			check_dollars(data, &src, &res, &len_buf);
			continue ;
		}
		if (!char_append(&res, &len_buf, *src))
			malloc_failed(data);
		src++;
	}
	free(data->line);
	data->line = res;
}


/* ======= fichier: ./Parsing/exit_code.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit_code.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 19:48:09 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/19 16:33:34 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	free_all(t_data *data, int exit_code, bool exit_or_not)
{
	free_env(&data->env);
	free_token(&data->token);
	free_cmd(&data->cmd);
	if (data->line)
	{
		free(data->line);
		data->line = NULL;
	}
	if (exit_or_not)
	{
		clear_history();
		exit(exit_code);
	}
}

void	malloc_failed(t_data *data)
{
	ft_putstr_fd("Cannot allocate memory\n", 2);
	free_all(data, 1, true);
}


/* ======= fichier: ./Parsing/free.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/22 22:31:47 by mlavry            #+#    #+#             */
/*   Updated: 2025/05/14 18:33:17 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	free_tab(char **tokens)
{
	int	i;

	if (!tokens)
		return ;
	i = 0;
	while (tokens[i])
	{
		free(tokens[i]);
		i++;
	}
	free(tokens);
}

/* void closefd(t_data *data)
{
	if (data->cmd->fd_in != STDIN_FILENO)
		close(data->cmd->fd_in);
	if (data->cmd->fd_out != STDOUT_FILENO)
		close(data->cmd->fd_out);
} */

void	close_all_fd(void)
{
	int	fd;

	fd = 3;
	if (fd > 1024)
		exit(0);
	while (fd < 1024)
	{
		close(fd);
		fd++;
	}
}

void	free_env(t_env **env)
{
	t_env	*tmp;

	if (!env || !*env)
		return ;
	while (*env)
	{
		tmp = (*env)->next;
		if ((*env)->name)
			free((*env)->name);
		if ((*env)->value)
			free((*env)->value);
		free(*env);
		*env = tmp;
	}
	*env = NULL;
}

void	free_token(t_token **token)
{
	t_token	*tmp;

	if (!token || !*token)
		return ;
	while (*token)
	{
		tmp = (*token)->next;
		if ((*token)->str)
			free((*token)->str);
		free(*token);
		*token = tmp;
	}
	*token = NULL;
}

void	free_cmd(t_cmd **cmd)
{
	t_cmd	*tmp;

	if (!cmd || !*cmd)
		return ;
	while (*cmd)
	{
		tmp = (*cmd)->next;
		if ((*cmd)->name)
			free((*cmd)->name);
		if ((*cmd)->args)
			free_tab((*cmd)->args);
		close_all_fd();
		free(*cmd);
		*cmd = tmp;
	}
	*cmd = NULL;
}


/* ======= fichier: ./Parsing/stock_tokens.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stock_tokens.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/22 20:48:09 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/19 16:55:03 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

static void	init_var(int pos[3], bool *sq, bool *dq)
{
	*sq = false;
	*dq = false;
	pos[0] = 0;
	pos[1] = 0;
	pos[2] = 0;
}

char *	handle_dq_joined(char *line, char *old_chain, bool *dq, int *pos)
{
	char	*temp;
	char	*res;
	bool	sq = false;

	temp = NULL;
	pos[1]++;
	pos[0] = pos[1];
	*dq = true;
	quote_choice(&sq, dq, line[pos[1]]);
	while (line[pos[1]] && *dq)
	{
		pos[1]++;
		quote_choice(&sq, dq, line[pos[1]]);
	}
	if (pos[1] > pos[0])
		temp = ft_substr(line, pos[0], pos[1] - pos[0]);
	pos[1]++;
	while (is_quoted(line[pos[1]]) && is_quoted(line[pos[1] + 1])
		&& line[pos[1]] == line[pos[1] + 1])
		pos[1] = pos[1] + 2;
	if (temp)
	{
		res = ft_strjoin(old_chain, temp);
		if (!is_space(line[pos[1]])
			&& !is_operator(line[pos[1]]))
			res = check_next(line, res, pos);
	}
	else
		return (old_chain);
	pos[0] = pos[1];
	return (res);
}

char *	handle_sq_joined(char *line, char *old_chain, bool *sq, int *pos)
{
	char	*temp;
	char	*res;
	bool	dq = false;

	temp = NULL;
	pos[1]++;
	pos[0] = pos[1];
	*sq = true;
	quote_choice(sq, &dq, line[pos[1]]);
	while (line[pos[1]] && *sq)
	{
		pos[1]++;
		quote_choice(sq, &dq, line[pos[1]]);
	}
	if (pos[1] > pos[0])
		temp = ft_substr(line, pos[0], pos[1] - pos[0]);
	pos[1]++;
	while (is_quoted(line[pos[1]]) && is_quoted(line[pos[1] + 1])
		&& line[pos[1]] == line[pos[1] + 1])
		pos[1] = pos[1] + 2;
	if (temp)
	{
		res = ft_strjoin(old_chain, temp);
		if (!is_space(line[pos[1]])
			&& !is_operator(line[pos[1]]))
			res = check_next(line, res, pos);
	}
	else
		return (old_chain);
	pos[0] = pos[1];
	return (res);
}

char	*handle_chain_joined(char *line, char *old_chain, int *pos)
{
	char	*temp;
	char	*res;
	bool	dq = false;
	bool	sq = false;

	temp = NULL;
	pos[0] = pos[1];
	quote_choice(&sq, &dq, line[pos[1]]);
	while (line[pos[1]] && !sq && !dq && !is_space(line[pos[1]])
		&& !is_operator(line[pos[1]]))
	{
		pos[1]++;
		quote_choice(&sq, &dq, line[pos[1]]);
	}
	if (pos[1] > pos[0])
		temp = ft_substr(line, pos[0], pos[1] - pos[0]);
	while (is_quoted(line[pos[1]]) && is_quoted(line[pos[1] + 1])
		&& line[pos[1]] == line[pos[1] + 1])
		pos[1] = pos[1] + 2;
	if (temp)
	{
		res = ft_strjoin(old_chain, temp);
		if (!is_space(line[pos[1]])
			&& !is_operator(line[pos[1]]))
			res = check_next(line, res, pos);
	}
	else
		return (old_chain);
	pos[0] = pos[1];
	return (res);
}

int	handle_sq(char *line, char **tokens, bool *sq, int *pos)
{
	char	*temp;
	bool	dq = false;

	temp = NULL;
	if (!*sq)
		return (0);
	pos[1]++;
	pos[0] = pos[1];
	if (is_operator(line[pos[1]]) && check_operators(line, tokens, pos))
	{
		pos[1]++;
		(*sq) = false;
		return (1);
	}
	quote_choice(sq, &dq, line[pos[1]]);
	while (line[pos[1]] && *sq)
	{
		pos[1]++;
		quote_choice(sq, &dq, line[pos[1]]);
	}
	if (pos[1] > pos[0])
		temp = ft_substr(line, pos[0], pos[1] - pos[0]);
	else
		temp = ft_strdup("");
	pos[1]++;
	while (is_quoted(line[pos[1]]) && is_quoted(line[pos[1] + 1])
		&& line[pos[1]] == line[pos[1] + 1])
		pos[1] = pos[1] + 2;
	pos[1]++;
	if (line[pos[1] - 1] && line[pos[1]]
		&& is_operator(line[pos[1]]) && (is_space(line[pos[1] - 1])
			|| !line[pos[1] - 1]) && check_operators(line, tokens, pos))
	{
		pos[1]++;
		(*sq) = false;
		return (1);
	}
	pos[1]--;
	if (!is_space(line[pos[1]])
		&& !is_operator(line[pos[1]]))
		temp = check_next(line, temp, pos);
	tokens[pos[2]++] = temp;
	pos[0] = pos[1];
	return (1);
}

int	handle_dq(char *line, char **tokens, bool *dq, int *pos)
{
	char	*temp;
	bool	sq = false;

	temp = NULL;
	if (!*dq)
		return (0);
	pos[1]++;
	pos[0] = pos[1];
	if (is_operator(line[pos[1]]) && check_operators(line, tokens, pos))
	{
		pos[1]++;
		(*dq) = false;
		return (1);
	}
	quote_choice(&sq, dq, line[pos[1]]);
	while (line[pos[1]] && *dq)
	{
		pos[1]++;
		quote_choice(&sq, dq, line[pos[1]]);
	}
	if (pos[1] > pos[0])
		temp = ft_substr(line, pos[0], pos[1] - pos[0]);
	else
		temp = ft_strdup("");
	pos[1]++;
	while (is_quoted(line[pos[1]]) && is_quoted(line[pos[1] + 1])
		&& line[pos[1]] == line[pos[1] + 1])
		pos[1] = pos[1] + 2;
	pos[1]++;
	if (line[pos[1] - 1] && line[pos[1]]
		&& is_operator(line[pos[1]]) && (is_space(line[pos[1] - 1])
			|| !line[pos[1] - 1]) && check_operators(line, tokens, pos))
	{
		pos[1]++;
		(*dq) = false;
		return (1);
	}
	pos[1]--;
	if (!is_space(line[pos[1]])
		&& !is_operator(line[pos[1]]))
		temp = check_next(line, temp, pos);
	tokens[pos[2]++] = temp;
	pos[0] = pos[1];
	return (1);
}

void	handle_operator(char *line, char **temp, int *pos)
{
	pos[0] = pos[1];
	while (line[pos[1]] == line[pos[0]])
		pos[1]++;
	*temp = ft_substr(line, pos[0], pos[1] - pos[0]);
	pos[0] = pos[1];
}

int	handle_unquoted(char *line, char **tokens, int *pos)
{
	char	*temp;
	bool	sq;
	bool	dq;

	temp = NULL;
	sq = false;
	dq = false;
	while (is_space(line[pos[1]]))
		pos[1]++;
	pos[0] = pos[1];
	quote_choice(&sq, &dq, line[pos[1]]);
	while (line[pos[1]] && !is_space(line[pos[1]]) && !is_operator(line[pos[1]])
		&& !sq && !dq)
	{
		pos[1]++;
		quote_choice(&sq, &dq, line[pos[1]]);
	}
	if (is_operator(line[pos[1]]))
	{
		if (pos[1] > pos[0])
			tokens[pos[2]++] = ft_substr(line, pos[0], pos[1] - pos[0]);
		handle_operator(line, &temp, pos);
		tokens[pos[2]++] = temp;
		return (1);
	}
	if (pos[1] > pos[0])
		temp = ft_substr(line, pos[0], pos[1] - pos[0]);
	if (is_quoted(line[pos[1]]) && is_operator(line[pos[1] + 1])
		&& (is_space(line[pos[1] - 1]) || !line[pos[1] - 1]))
	{
		pos[1]++;
		if (check_operators(line, tokens, pos))
		{
			quote_choice(&sq, &dq, line[pos[1]]);
			pos[1]++;
			return (1);
		}
		pos[1]--;
	}
	if (!temp && line[pos[1]])
		temp = ft_strdup("");
	while (line[pos[1]] && line[pos[1] + 1]
		&& is_quoted(line[pos[1]]) && is_quoted(line[pos[1] + 1])
		&& line[pos[1]] == line[pos[1] + 1])
		pos[1] = pos[1] + 2;
	pos[1]++;
	if (line[pos[1] - 1] && line[pos[1]]
		&& is_operator(line[pos[1]]) && (is_space(line[pos[1] - 1])
			|| !line[pos[1] - 1]) && check_operators(line, tokens, pos))
	{
		quote_choice(&sq, &dq, line[pos[1]]);
		pos[1]++;
		return (1);
	}
	pos[1]--;
	if (temp)
	{
		if (!is_space(line[pos[1]])
			&& !is_operator(line[pos[1]]))
			temp = check_next(line, temp, pos);
		tokens[pos[2]++] = temp;
	}
	pos[0] = pos[1];
	return (1);
}

char	*check_next(char *line, char *actual_chain, int *pos)
{
	bool	dq;
	bool	sq;
	char	*res;

	dq = false;
	sq = false;
	res = actual_chain;
	quote_choice(&sq, &dq, line[pos[1]]);
	if (sq)
		res = handle_sq_joined(line, actual_chain, &sq, pos);
	else if (dq)
		res = handle_dq_joined(line, actual_chain, &dq, pos);
	else
		res = handle_chain_joined(line, actual_chain, pos);
	return (res);
}

char	**line_to_token(t_data *data)
{
	char	**tokens;
	int		pos[3];
	bool	sq;
	bool	dq;

	init_var(pos, &sq, &dq);
	tokens = malloc(sizeof(char *) * (count_tokens(data->line) + 1));
	if (!tokens)
		return (NULL);
	while (data->line[pos[1]])
	{
		quote_choice(&sq, &dq, data->line[pos[1]]);
		if (!sq && !dq && handle_unquoted(data->line, tokens, pos))
			continue ;
		if (handle_sq(data->line, tokens, &sq, pos)
			|| handle_dq(data->line, tokens, &dq, pos))
			continue ;
		pos[1]++;
	}
	tokens[pos[2]] = NULL;
	return (tokens);
}


/* ======= fichier: ./Parsing/handle_commands_type.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_commands_type.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/12 18:34:37 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/16 23:58:50 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

 bool	handle_heredoc_type(t_token *t, t_token **tok, t_cmd *cur)
{
	if (!t->next || t->next->type != ARG)
	{
		ft_putstr_fd("shel: syntax error near unexpected token `newline'\n", 2);
		g_exit_status = 2;
		return (false);
	}
	if (!handle_heredoc(tok, cur))
		return (false);
	*tok = (*tok)->next->next;
	return (true);
} 

bool	handle_cmd_type(t_token *tok, t_cmd **hd, t_cmd **cur, t_token **tokens)
{
	bool	ok;

	ok = handle_cmd(hd, cur, tok);
	*tokens = tok->next;
	return (ok);
}

bool	handle_arg_type(t_token *tok, t_cmd *cur, t_token **tokens)
{
	bool	ok;

	ok = handle_arg(cur, tok);
	*tokens = tok->next;
	return (ok);
}

bool	handle_redirectarg_type(t_token *tok, t_token **tokens)
{
	if (tok && tok->prev && tok->prev->type
		&& (tok->prev->type == OUTPUT
			|| tok->prev->type == INPUT
			|| tok->prev->type == APPEND
			|| tok->prev->type == HEREDOC))
	{
		*tokens = tok->next;
		return (true);
	}
	return (false);
}


/* ======= fichier: ./Parsing/init_struct.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_struct.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/12 19:51:27 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/16 23:42:22 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

/* static void	init_token(t_token *token)
{
	token->str = NULL;
	token->type = 0;
	token->sq = false;
	token->dq = false;
	token->next = NULL;
	token->prev = NULL;
}

static void	init_cmd(t_cmd *cmd)
{
	cmd->name = NULL;
	cmd->args = NULL;
	cmd->fd_in = 0;
	cmd->fd_out = 1;
	cmd->next = NULL;
} */

void	init_data(t_data *data, int argc, char **argv, char **envp)
{
	ft_bzero(data, sizeof(t_data));
	(void)envp;
	(void)argc;
	(void)argv;
	data->env = NULL;
	data->cmd = NULL;
	data->token = NULL;
	data->line = NULL;
	g_exit_status = 0;
}


/* ======= fichier: ./Parsing/line_to_token.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   line_to_token.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/15 21:47:49 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/17 23:37:20 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	count_tokens(char *line)
{
	size_t	i = 0;
	int		tokens = 0;
	bool	sq = false;
	bool	dq = false;

	while (line && line[i])
	{
		while (is_space(line[i]))
			i++;
		if (!line[i])
			break ;
		tokens++;
		if (!sq && !dq && is_operator(line[i]))
		{
			char op = line[i];
			while (line[i] == op)
				i++;
		}
		else
		{
			while (line[i])
			{
				quote_choice(&sq, &dq, line[i]);
				if (!sq && !dq && (is_space(line[i]) || is_operator(line[i])))
					break ;
				i++;
			}
		}
	}
	return (tokens);
}


/* ======= fichier: ./Parsing/make_commands.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   make_commands.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/29 22:08:30 by mlavry            #+#    #+#             */
/*   Updated: 2025/05/06 15:15:58 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

bool	is_redir(int type)
{
	return (type == HEREDOC || type == INPUT
		|| type == OUTPUT || type == APPEND);
}

void	mark_commands(t_data *data)
{
	t_token	*prev;
	t_token	*curr;

	prev = NULL;
	curr = data->token;
	while (curr)
	{
		if (curr->type == ARG)
		{
			if (!prev || prev->type == PIPE)
				curr->type = CMD;
		}
		prev = curr;
		curr = curr->next;
	}
}

static int	arg_count(char **args)
{
	int	i;

	i = 0;
	while (args && args[i])
		i++;
	return (i);
}

static char	**ft_grow(char **old, int size)
{
	char	**new;
	int		i;

	i = -1;
	new = malloc(sizeof(char *) * (size + 2));
	if (!new)
		return (NULL);
	while (++i < size)
		new[i] = old[i];
	new[i] = NULL;
	new[i + 1] = NULL;
	free(old);
	return (new);
}

int	add_args(char ***args, char *str)
{
	char	**tmp;
	int		nb;

	if (!*args)
	{
		*args = malloc(sizeof(char *) * 2);
		if (!*args)
			return (0);
		(*args)[0] = ft_strdup(str);
		if (!(*args)[0])
			return (0);
		(*args)[1] = NULL;
		return (1);
	}
	nb = arg_count(*args);
	tmp = ft_grow(*args, nb);
	if (!tmp)
		return (0);
	tmp[nb] = ft_strdup(str);
	if (!tmp[nb])
		return (0);
	tmp[nb + 1] = NULL;
	*args = tmp;
	return (1);
}


/* ======= fichier: ./Parsing/check_op_syntax.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_op_syntax.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/19 18:10:46 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/19 19:00:44 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

static bool	is_same_op_sequence(const char *s)
{
	char	op;

	if (!s || !*s)
		return (false);
	op = s[0];
	if (!is_operator(op))
		return (false);
	while (*s)
	{
		if (*s != op)
			return (false);
		s++;
	}
	return (true);
}

static void	ft_putnchar_fd(char c, size_t n, int fd)
{
	while (n--)
		ft_putchar_fd(c, fd);
}

bool	check_arg_op_syntax(t_token *tok)
{
	size_t	len;
	char	op;
	size_t	limit;
	size_t	print;

	if (tok->type != ARG && tok->type != CMD)
		return (true);
	if (!is_same_op_sequence(tok->str))
		return (true);
	len = ft_strlen(tok->str);
	op = tok->str[0];
	if (op == '|')
		limit = 1;
	if (op == '>' || op == '<')
		limit = 2;
	if (len > limit)
	{
		print = len - limit;
		if (print > limit)
			print = limit;
		ft_putstr_fd("minishell: syntax error near unexpected token `", 2);
		ft_putnchar_fd(op, print, 2);
		ft_putstr_fd("'\n", 2);
		g_exit_status = 2;
		return (false);
	}
	return (true);
}


/* ======= fichier: ./Parsing/handle_commands.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_commands.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/12 18:33:00 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/17 00:01:51 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	handle_cmd(t_cmd **head, t_cmd **cur, t_token *tokens)
{
	t_cmd	*new;

	new = ft_calloc (1, sizeof(t_cmd));
	if (!new)
		return (0);
	new->name = ft_strdup(tokens->str);
	if (!new->name)
	{
		free(new);
		return (0);
	}
	new->fd_in = STDIN_FILENO;
	new->fd_out = STDOUT_FILENO;
	if (!add_args(&new->args, new->name))
	{
		free(new->name);
		free(new);
		return (0);
	}
	if (!(*head))
		(*head) = new;
	else
		(*cur)->next = new;
	(*cur) = new;
	return (1);
}

int	handle_arg(t_cmd *cur, t_token *token)
{
	if (!cur)
		return (0);
	if (!add_args(&cur->args, token->str))
		return (0);
	return (1);
}

t_cmd	*create_new_cmd(void)
{
	t_cmd	*cmd;

	cmd = malloc(sizeof(t_cmd));
	if (!cmd)
		return (NULL);
	cmd->args = NULL;
	cmd->fd_in = STDIN_FILENO;
	cmd->fd_out = STDOUT_FILENO;
	cmd->next = NULL;
	return (cmd);
}



bool is_redirection(int type)
{
	return (type == OUTPUT || type == APPEND || type == INPUT || type == HEREDOC);
}

int handle_redirect_after_pipe(t_token **tokens, t_cmd **cur)
{
	while (*tokens && is_redirection((*tokens)->type))
	{
		int type = (*tokens)->type;

		if (type == OUTPUT)
		{
			if (!handle_output(tokens, cur))
				return (0);
		}
		else if (type == APPEND)
		{
			if (!handle_append(tokens, cur))
				return (0);
		}
		else if (type == INPUT)
		{
			if (!handle_input(tokens, cur))
				return (0);
		}
		else if (type == HEREDOC)
		{
			if (!handle_heredoc_type(*tokens, tokens, *cur))
				return (0);
		}
	}
	return (1);
}

int handle_pipe(t_token **tokens, t_cmd **cur)
{

    if (!tokens || !*tokens)
        return 0;
    if ((*tokens)->type == PIPE && (!(*tokens)->next))
    {
        printf("minishell: syntax error near unexpected token `|'\n");
        return 0;
    }
    *tokens = (*tokens)->next;

    // CAS 1 : Le token suivant est une redirection (sans commande explicite)
    if (*tokens && is_redirection((*tokens)->type))
    {
        // S'il n'y a pas encore de commande en cours, en crÃ©er une vide
        if (!*cur)
            *cur = create_new_cmd();

        // Appeler la fonction qui gÃ¨re la redirection aprÃ¨s un pipe
        if (!handle_redirect_after_pipe(tokens, cur))
            return 0; // erreur dans la redirection

        // Ici, on a traitÃ© la redirection, on continue normalement
        return 1;
    }

    if (!*cur)
        *cur = create_new_cmd();

    // On continue normalement la lecture / parsing
    return 1;
} 



/* int	handle_pipe(t_token **tokens, t_cmd **cur)
{
	if (!cur || !*cur)
		return (0);
	if ((*tokens)->type == PIPE && (!(*tokens)->next))
	{
		printf("minishell: syntax error near unexpected token `|'\n");
		return (0);
	}

	*tokens = (*tokens)->next;
	if (*tokens && is_redirection((*tokens)->type))
	{
    	if (!*cur)
        	*cur = create_new_cmd(); // CrÃ©e un t_cmd vide

    	if (handle_redirect_after_pipe(tokens, cur))
			return 0;
	}
	if (!cur || !*cur)
		return (0); 
	return (1);
}  */


int	handle_output(t_token **tokens, t_cmd **cur)
{
	if (!cur || !*cur)
		return (0);
	if ((*cur)->args == NULL && (*cur)->name == NULL)
	{
		(*cur)->name = ft_strdup(""); // pour signaler que ce t_cmd existe
		(*cur)->fd_in = STDIN_FILENO;
		(*cur)->fd_out = STDOUT_FILENO;
	}	
	if (((*tokens)->type == OUTPUT || (*tokens)->type == APPEND || (*tokens)->type == INPUT || (*tokens)->type == HEREDOC)
		&& (!(*tokens)->next || (*tokens)->next->type != ARG))
	{
		ft_putstr_fd("shel: syntax error near unexpected token `newline'\n", 2);
		g_exit_status = 2;
		return (0);
	}
	if ((*tokens)->next && (*tokens)->next->type == ARG)
	{
		if ((*cur)->fd_out != STDOUT_FILENO && (*cur)->fd_out != -1)
			close((*cur)->fd_out);
		(*cur)->fd_out = open((*tokens)->next->str,
				O_CREAT | O_WRONLY | O_TRUNC | __O_CLOEXEC, 0644);
		if ((*cur)->fd_out < 0)
		{
			printf("%s: No such file or directory\n", (*tokens)->next->str);
			return (0);
		}
		*tokens = (*tokens)->next;
	}
	return (1);
}

int	handle_input(t_token **tokens, t_cmd **cur)
{
	if (!cur || !*cur)
		return (0);
	if (tokens && ((*tokens)->type == INPUT)
		&& (!(*tokens)->next || (*tokens)->next->type != ARG))
	{
		ft_putstr_fd("shel: syntax error near unexpected token `newline'\n", 2);
		g_exit_status = 2;
		return (0);
	}
	if ((*tokens)->next && (*tokens)->next->type == ARG)
	{
		if ((*cur)->fd_in != STDIN_FILENO)
			close((*cur)->fd_in);
		(*cur)->fd_in = open((*tokens)->next->str, O_RDONLY | __O_CLOEXEC);
		if ((*cur)->fd_in < 0)
		{
			printf("%s: No such file or directory\n", (*tokens)->next->str);
			return (0);
		}

		*tokens = (*tokens)->next;
	}
	return (1);
}


/* ======= fichier: ./Parsing/parsing_start.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_start.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/08 18:55:39 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/19 22:47:40 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"


void	set_token_prev_links(t_token *tokens)
{
	t_token	*prev;

	prev = NULL;
	while (tokens)
	{
		tokens->prev = prev;
		prev = tokens;
		tokens = tokens->next;
	}
}

bool	check_redirection_syntax(t_token *tok)
{
	if (!tok->next || tok->next->type != ARG)
	{
		ft_putstr_fd("minishell: syntax error near unexpected token `", 2);
		if (!tok->next)
			ft_putstr_fd("newline", 2);
		else
			ft_putstr_fd(tok->next->str, 2);
		ft_putstr_fd("'\n", 2);
		g_exit_status = 2;
		return (false);
	}
	return (true);
}

bool	check_pipe_syntax(t_token *tok)
{
	if (!tok->prev || !tok->next)
	{
		ft_putstr_fd("minishell: syntax error near unexpected token `|'\n", 2);
		g_exit_status = 2;
		return (false);
	}
   // Optionnel : vÃ©rifier que tokens->prev et tokens->next ne sont pas PIPE ou opÃ©rateurs
	if (tok->prev->type == PIPE || tok->next->type == PIPE)
	{
		ft_putstr_fd("minishell: syntax error near unexpected token `|'\n", 2);
		g_exit_status = 2;
		return (false);
	}
	return (true);
}

bool	validate_tokens(t_token *tokens)
{
	while (tokens)
	{
		if (tokens->type == OUTPUT || tokens->type == INPUT
			|| tokens->type == APPEND || tokens->type == HEREDOC)
		{
			if (!check_redirection_syntax(tokens))
				return (false);
		}
		else if (tokens->type == PIPE)
		{
			if (!check_pipe_syntax(tokens))
				return (false);
		}
		tokens = tokens->next;
	}
	return (true);
}

bool	parse_line(t_data *data)
{
	if (open_quote(data->line))
	{
		free(data->line);
		return (false);
	}
	replace_dollars(data);
	if (!tokenize(data))
	{
		free(data->line);
		return (false);
	}
	set_token_prev_links(data->token);
	if (!validate_tokens(data->token))
	{
		free(data->line);
		free_token(&data->token);
		return (false);
	}
	data->cmd = tokens_to_commands(data->token);
	if (!(data->cmd))
	{
		free(data->line);
		return (false);
	}
	//print_cmds(data->cmd);
	return (true);
}


/* ======= fichier: ./Parsing/token_to_commands.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_to_commands.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 17:28:02 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/19 02:40:07 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	handle_append(t_token **tokens, t_cmd **cur)
{
	if (!cur || !*cur)
		return (0);
 	if ((*tokens)->type == APPEND && (!(*tokens)->prev
			|| !(*tokens)->next || (*tokens)->next->type != ARG))
	{
		ft_putstr_fd("shel: syntax error near unexpected token `newline'\n", 2);
		g_exit_status = 2;
		return (0);
	}
	if ((*tokens) && (*tokens)->type == APPEND
		&& (*tokens)->next && (*tokens)->next->type == ARG)
	{
		if ((*cur)->fd_out != STDOUT_FILENO && (*cur)->fd_out != -1)
			close((*cur)->fd_out);
		(*cur)->fd_out = open((*tokens)->next->str,
				O_WRONLY | O_CREAT | O_APPEND, 0644);
		if ((*cur)->fd_out < 0)
		{
			perror("open");
			return (0);
		}
		*tokens = (*tokens)->next->next;
	}
	return (1);
}

char	*heredoc_tmp(void)
{
	static int	i = 0;
	char		*num;
	char		*filename;

	num = ft_itoa(i++);
	filename = ft_strjoin("/tmp/heredoc_%d.tmp", num);
	free(num);
	return (filename);
}

/* int	write_heredoc(char *delimiter, int tmp_fd)
{
	char	*line;
	char	*newline;

	while (1)
	{
		reset_signals_to_default();
		write(1, "> ", 2);
		line = get_next_line(0);
		if (!line)
			break ;
		newline = ft_strchr(line, '\n');
		if (newline)
			*newline = '\0';
		if (ft_strcmp(line, delimiter) == 0)
		{
			free(line);
			break ;
		}
		write(tmp_fd, line, ft_strlen(line));
		write(tmp_fd, "\n", 1);
		free(line);
	}
	return (1);
} */

int write_heredoc(char *delimiter, int tmp_fd)
{
    char               *line;
    char               *newline;
    struct sigaction    old_int;
    int                 saved_status = g_exit_status;
	bool				eof = false;

	disable_echoctl();
    hd_set_signals(&old_int);
    g_exit_status = 0;
    while (1)
    {
        write(STDOUT_FILENO, "> ", 2);
        line = get_next_line(STDIN_FILENO);
        if (!line)
		{
			eof = true;
            break ;
		}
        if (g_exit_status == 130)
        {
            free(line);
            break;
        }
        newline = ft_strchr(line, '\n');
        if (newline)
            *newline = '\0';
        if (ft_strcmp(line, delimiter) == 0)
        {
            free(line);
            break;
        }
        write(tmp_fd, line, ft_strlen(line));
        write(tmp_fd, "\n", 1);
        free(line);
    }
	enable_echoctl();
    hd_restore_signals(&old_int);
	if (eof && g_exit_status != 130)
	{
		printf("\n");
		printf("minishell: warning: here-document delimited by end-of-file "
			"(wanted `%s')\n", delimiter);
	}
    if (g_exit_status != 130)
        g_exit_status = saved_status;
    return (g_exit_status == 130 ? -1 : 0);
}

int	handle_heredoc(t_token **tokens, t_cmd *cur)
{
	char	*delimiter;
	char	*tmp_filename;
	int		tmp_fd;

	delimiter = (*tokens)->next->str;
	tmp_filename = heredoc_tmp();
	tmp_fd = open(tmp_filename, O_WRONLY | O_CREAT | O_TRUNC, 0600);
	if (tmp_fd == -1)
		return (perror("open tmp"), 0);
	if (!tokens || !*tokens || !(*tokens)->next)
		return (0);
	if (write_heredoc(delimiter, tmp_fd) == -1)
	{
		close(tmp_fd);
		unlink(tmp_filename);
		g_exit_status = 130;
		return (0);
	}
	if (cur->fd_in != STDIN_FILENO)
		close(cur->fd_in);
	cur->fd_in = open(tmp_filename, O_RDONLY);
	if (cur->fd_in == -1)
		return (perror("open heredoc read"), 0);
	free(tmp_filename);
	return (1);
}

/* int	handle_heredoc(t_token **tokens, t_cmd *cur)
{
	char	*delimiter;
	char	*tmp_filename;
	int		tmp_fd;

	delimiter = (*tokens)->next->str;
	tmp_filename = heredoc_tmp();
	tmp_fd = open(tmp_filename, O_WRONLY | O_CREAT | O_TRUNC, 0600);
	if (tmp_fd == -1)
		return (perror("open tmp"), 0);
	if (!tokens || !*tokens || !(*tokens)->next)
		return (0);
	write_heredoc(delimiter, tmp_fd);
	close(tmp_fd);
	if (cur->fd_in != STDIN_FILENO)
		close(cur->fd_in);
	cur->fd_in = open(tmp_filename, O_RDONLY);
	unlink(tmp_filename);
	if (cur->fd_in == -1)
		return (perror("open heredoc read"), 0);
	free(tmp_filename);
	return (1);
} */

/* bool check_token_syntax(t_token *tokens, t_data *data)
{
    while (tokens)
    {
        // VÃ©rifie si le token est un pipe
        if (tokens->type == PIPE)
        {
			 if (!tokens->prev || !tokens->next)
   			 {
        		printf("minishell: syntax error near unexpected token `|'\n");
        		g_exit_status = 2;
        		return false;
    		}
            // Si le token prÃ©cÃ©dent est une redirection, c'est une erreur
            if (tokens->prev && (tokens->prev->type == OUTPUT || tokens->prev->type == HEREDOC || tokens->prev->type == APPEND || tokens->prev->type == INPUT))
            {
                printf("minishell: syntax error near unexpected token `%s'\n", tokens->str);
                g_exit_status = 2;
                return false;
            }
        }

        // VÃ©rifie si le token est une redirection sans fichier suivant
        if ((tokens->type == OUTPUT || tokens->type == APPEND || tokens->type == INPUT) && (!tokens->next || tokens->next->type != ARG))
        {
            printf("minishell: syntax error near unexpected token `%s'\n", tokens->next ? tokens->next->str : "newline");
            g_exit_status = 2;
            return false;
        }

        tokens = tokens->next;
    }
    return true;
} */


/* bool	handle_redirect_after_pipe(t_token **tokens, t_cmd **cur)
{
	t_token *tok = *tokens;

	// VÃ©rifie si on est bien sur un token de redirection
	if (!tok || !(tok->type == OUTPUT || tok->type == APPEND || tok->type == INPUT || tok->type == HEREDOC))
		return (false);

	t_cmd *cmd = *cur;

	// On gÃ¨re chaque type de redirection
	if (tok->type == OUTPUT)
		return handle_output(tokens, &cmd);
	else if (tok->type == APPEND)
		return handle_append(tokens, &cmd);
	else if (tok->type == INPUT)
		return handle_input(tokens, &cmd);
	else if (tok->type == HEREDOC)
		return handle_heredoc_type(tok, tokens, cmd);

	return false;
} */


static bool	is_type_token(t_token **tokens, t_cmd **head, t_cmd **cur)
{
	t_token	*tok;

	tok = *tokens;
	if (!tok)
		return (false);
	/* if (tok->type == HEREDOC)
		return (handle_heredoc_type(tok, tokens, *cur));
	if (tok->type == ARG && handle_redirectarg_type(tok, tokens))
		return (true);
	if (tok->type == CMD)
		return (handle_cmd_type(tok, head, cur, tokens));
	if (tok->type == ARG)
		return (handle_arg_type(tok, *cur, tokens));
	if (tok->type == OUTPUT)
		return (handle_output(tokens, cur));
	if (tok->type == INPUT)
		return (handle_input(tokens, cur));
	if (tok->type == PIPE)
		return (handle_pipe(tokens, cur));
	if (tok->type == APPEND)
		return (handle_append(tokens, cur));
 */

	if (tok->type == HEREDOC)
    	return (handle_heredoc_type(tok, tokens, *cur));
	else if (tok->type == OUTPUT)
   	 	return (handle_output(tokens, cur));
	else if (tok->type == APPEND)
    	return (handle_append(tokens, cur));
	else if (tok->type == INPUT)
   	 	return (handle_input(tokens, cur));
	else if (tok->type == PIPE)
    	return (handle_pipe(tokens, cur));
 	else if (tok->type == ARG && handle_redirectarg_type(tok, tokens))
    	return (true); 
	else if (tok->type == CMD)
    	return (handle_cmd_type(tok, head, cur, tokens));	
	else if (tok->type == ARG)
   	 return (handle_arg_type(tok, *cur, tokens));

	return (true);
}



t_cmd	*tokens_to_commands(t_token *tokens)
{
	t_cmd	*head;
	t_cmd	*cur;

	head = NULL;
	cur = NULL;

/* 	if ((tokens->type == PIPE && (!tokens->next || tokens->next->type == PIPE
				|| tokens->next->type == OUTPUT)) || (tokens->type == OUTPUT
			&& (!tokens->next || tokens->next->type != CMD)))
	{
		printf("shell: syntax error near unexpected token\n");
		return (free_cmd(&head), NULL);
	} */
	if (tokens && (tokens->type == OUTPUT || tokens->type == INPUT
			|| tokens->type == APPEND || tokens->type == HEREDOC))
	{
		cur = ft_calloc(1, sizeof(t_cmd));
		if (!cur)
			return (NULL);
		cur->fd_in = STDIN_FILENO;
		cur->fd_out = STDOUT_FILENO;
		cur->name = ft_strdup("");
		head = cur;
	}
	g_exit_status = 0;
	while (tokens)
	{
		if (g_exit_status == 130)
			break ;
		if (!is_type_token (&tokens, &head, &cur))
		{
			free_cmd(&head);
			return (NULL);
		}
	}
	return (head);
}

/*  void print_cmds(t_cmd *c)
{
    int idx;
    while (c)
    {
        printf("=== Command: %s ===\n", c->name);
        for (idx = 0; c->args && c->args[idx]; idx++)
            printf("  arg[%d]: %s\n", idx, c->args[idx]);
        printf("  fd_in = %d, fd_out = %d\n", c->fd_in, c->fd_out);
        c = c->next;
    }
}  */


/* ======= fichier: ./Parsing/tokenize.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/08 18:41:00 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/19 23:02:34 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	get_token_type(char *str)
{
	if (!ft_strcmp(str, "<"))
		return (INPUT);
	if (!ft_strcmp(str, "<<"))
		return (HEREDOC);
	if (!ft_strcmp(str, ">"))
		return (OUTPUT);
	if (!ft_strcmp(str, ">>"))
		return (APPEND);
	if (!ft_strcmp(str, "|"))
		return (PIPE);
	else
		return (ARG);
}

static void	check_value(t_token *token)
{
	int		i;
	char	type_quote;
	char	*res;

	i = 1;
	if (is_quoted(token->str[0]) && is_operator(token->str[1]))
	{
		type_quote = token->str[0];
		while (is_operator(token->str[i]))
			i++;
		if (token->str[i] == type_quote && !(token->str[i + 1]))
		{
			res = ft_substr(token->str, 1, i - 1);
			free(token->str);
			token->str = res;
			token->type = ARG;
		}
	}
}

int	add_token(t_token **head, char *value)
{
	t_token	*new;
	t_token	*tmp;

	new = malloc(sizeof(t_token));
	if (!new)
		return (0);
	new->str = ft_strdup(value);
	new->type = get_token_type(new->str);
	if (!check_arg_op_syntax(new))
		return (0);
	check_value(new);
	new->next = NULL;
	if (!*head)
		*head = new;
	else
	{
		tmp = *head;
		while (tmp->next)
			tmp = tmp->next;
		tmp->next = new;
	}
	return (1);
}

int	parse_token(t_data *data, char **tokens)
{
	int		i;
	t_token	*token_list;

	token_list = NULL;
	i = 0;
	while (tokens[i])
	{
		if (!add_token(&token_list, tokens[i]))
			return (0);
		i++;
	}
	data->token = token_list;
	mark_commands(data);
/* 	t_token *tmp = token_list;
 	while (tmp)
	{
		printf("Token: %-15s | Type: %-2d\n",
		tmp->str, tmp->type);
		tmp = tmp->next;
	} */
	return (1);
}

int	tokenize(t_data *data)
{
	char	**token;

	token = line_to_token(data);
	if (!token)
	{
		g_exit_status = 2;
		return (0);
	}
	if (!parse_token(data, token))
		return (0);
	free_tab(token);
	return (1);
}


/* ======= fichier: ./Utils/signal.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/16 20:59:28 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/19 01:06:40 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

static void	sigint_prompt(int sig)
{
	(void)sig;
	write(1, "\n", 1);
	rl_on_new_line();
	rl_replace_line("", 0);
	rl_redisplay();
	g_exit_status = 130;
}

void	init_signals_prompt(void)
{
	struct sigaction	sa;

	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = sigint_prompt;
	sigemptyset(&sa.sa_mask);
	sigaction(SIGINT, &sa, NULL);
	signal(SIGQUIT, SIG_IGN);
}

void    handle_status_and_print(int status)
{
    if (WIFSIGNALED(status))
    {
        	int sig = WTERMSIG(status);
			if (sig == SIGINT || sig == SIGQUIT)
			{
    			if (sig == SIGINT)
            		write(STDOUT_FILENO, "\n", 1);
        		else if (sig == SIGQUIT)
            		write(STDOUT_FILENO, "Quit\n", 5);
        		g_exit_status = 128 + sig;
			}
    }
    else
        g_exit_status = WEXITSTATUS(status);
}

void	reset_signals_to_default(void)
{
	struct sigaction	sa;

	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = SIG_DFL;
	sigemptyset(&sa.sa_mask);
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGQUIT, &sa, NULL);
}

void	ignore_sigint(void)
{
	signal(SIGINT, SIG_IGN);
}


/* ======= fichier: ./Utils/utils.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 20:29:56 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/17 22:49:17 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

char	*ft_strcat(char *dest, char *src)
{
	int	i;
	int	o;

	i = 0;
	o = 0;
	while (dest[i] != '\0')
	{
		i++;
	}
	while (src[o] != '\0')
	{
		dest[i] = src[o];
		i++;
		o++;
	}
	dest[i] = '\0';
	return (dest);
}

char	*ft_strcpy(char *dest, const char *src)
{
	int	i;

	i = 0;
	while (src[i] != '\0')
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = '\0';
	return (dest);
}

int	ft_strcmp(char *s1, char *s2)
{
	int	i;

	if (!s1 || !s2)
		return (-1);
	i = 0;
	while (s1[i] != '\0' && s2[i] != '\0')
	{
		if (s1[i] != s2[i])
			return (s1[i] - s2[i]);
		i++;
	}
	return (s1[i] - s2[i]);
}

int	str_append(char **res, int *len_buf, const char *add)
{
	size_t	add_len;
	char	*new;

	add_len = ft_strlen(add);
	new = malloc((size_t)(*len_buf + add_len) + 1);
	if (!new)
		return (0);
	if (*res)
	{
		ft_memcpy(new, *res, *len_buf);
		free(*res);
	}
	ft_memcpy(new + *len_buf, add, add_len + 1);
	*res = new;
	*len_buf += add_len;
	return (1);
}

int	char_append(char **res, int *len_buf, char c)
{
	char	tmp[2];

	tmp[0] = c;
	tmp[1] = '\0';
	return (str_append(res, len_buf, tmp));
}


/* ======= fichier: ./Utils/utils_2.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_2.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/20 17:46:33 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/17 22:49:07 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	is_operator(char c)
{
	if (c == '|' || c == '<' || c == '>')
		return (1);
	return (0);
}

int	is_space(char c)
{
	if (c == ' ' || (c >= 9 && c <= 13))
		return (1);
	return (0);
}

int	big_heredoc(char *str, int i)
{
	if (ft_strcmp(&str[i], "<<<<") == 0)
	{
		printf("bash: syntax error near unexpected token `<'\n");
		return (1);
	}
	else if (ft_strcmp(&str[i], "<<<<<") == 0)
	{
		printf("bash: syntax error near unexpected token `<<'\n");
		return (1);
	}
	return (0);
}

int	is_multiple_heredoc(char *str)
{
	int	i;

	i = 0;
	while (str[i])
	{
		if (big_heredoc(str, i))
			return (1);
		if (ft_strcmp(&str[i], "<") == 0 || ft_strcmp(&str[i], "<<") == 0
			|| ft_strcmp(&str[i], "<<<") == 0)
		{
			printf("bash: syntax error near unexpected token `newline'\n");
			return (1);
		}
		else
		{
			while (str[i] == '<')
			{
				printf("bash: syntax error near unexpected token `<<<'\n");
				return (1);
			}
		}
		i++;
	}
	return (0);
}

int	is_multiple_append(char *str)
{
	while (*str)
	{
		if (ft_strcmp(str, ">>>") == 0)
		{
			printf("bash: syntax error near unexpected token `>'\n");
			return (1);
		}
		else if (ft_strcmp(str, ">") == 0 || ft_strcmp(str, ">>") == 0)
		{
			printf("bash: syntax error near unexpected token `newline'\n");
			return (1);
		}
		else
		{
			while (*str == '>')
			{
				printf("bash: syntax error near unexpected token `>>'\n");
				return (1);
			}
		}
		str++;
	}
	return (0);
}


/* ======= fichier: ./Utils/utils_3.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_3.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/02 23:44:24 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/16 23:39:21 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	ft_isnumeric(const char *str)
{
	int	i;

	i = 0;
	if (!str || !*str)
		return (0);
	while (is_space(str[i]))
		i++;
	if (str[i] == '+' || str[i] == '-')
		i++;
	while (str[i])
	{
		if (!ft_isdigit(str[i]) && !is_space(str[i]))
			return (0);
		i++;
	}
	return (1);
}

int	check_operators(char *line, char **tokens, int *pos)
{
	char	quote_actual;
	int		old_pos;

	pos[0] = pos[1] - 1;
	old_pos = pos[1];
	quote_actual = line[pos[1] - 1];
	while (is_operator(line[pos[1]]))
		pos[1]++;
	if (is_quoted(line[pos[1]]) && line[pos[1]] == quote_actual
		&& (!line[pos[1] + 1]
			|| is_space(line[pos[1] + 1]) || is_operator(line[pos[1] + 1])))
	{
		tokens[pos[2]++] = ft_substr(line, pos[0], pos[1] - pos[0] + 1);
		pos[0] = pos[1];
		return (1);
	}
	pos[1] = old_pos;
	pos[0] = pos[1];
	return (0);
}

void	handle_command_error(char *cmd, char *msg, int exit_code, t_data *data)
{
	if (data)
		g_exit_status = exit_code;
	//ft_putstr_fd("minishell: ", 2);
	if (cmd)
	{
		ft_putstr_fd(cmd, 2);
		ft_putstr_fd(": ", 2);
	}
	ft_putstr_fd(msg, 2);
	exit(exit_code);
}


/* ======= fichier: ./Utils/signal_hd.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal_hd.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/18 00:50:33 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/18 21:00:20 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

static void  sigint_hd(int signo)
{
    (void)signo;
    g_exit_status = 130;
    write(STDOUT_FILENO, "^C\n", 3);
}

void    hd_set_signals(struct sigaction *old_int)
{
    struct sigaction sa;

    sa.sa_handler = sigint_hd;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags  = 0;
    sigaction(SIGINT, &sa, old_int);
	signal(SIGQUIT, SIG_IGN);
}

void    hd_restore_signals(const struct sigaction *old_int)
{
    sigaction(SIGINT,  old_int,  NULL);
}

void    disable_echoctl(void)
{
    struct termios  t;

    if (tcgetattr(STDIN_FILENO, &t) == -1)
        return ;
    t.c_lflag &= ~ECHOCTL;
    tcsetattr(STDIN_FILENO, TCSANOW, &t);
}

void	enable_echoctl(void)
{
	struct termios	term;

	if (tcgetattr(STDIN_FILENO, &term) == -1)
		return ;
	term.c_lflag |= ECHOCTL;
	tcsetattr(STDIN_FILENO, TCSANOW, &term);
}


/* ======= fichier: ./main.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/26 17:55:00 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/19 17:17:15 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	g_exit_status;

bool	empty_line(char *line)
{
	int	i;

	i = 0;
	while (line[i] && (line[i] == ' ' || line[i] == ':' || line[i] == '.'))
	{
		i++;
		g_exit_status = 0;
	}
	if (line[0] == '|')
	{
		printf("bash: syntax error near unexpected token `|'\n");
		g_exit_status = 2;
		return (true);
	}
	if (line[i] == '!')
	{
		i++;
		g_exit_status = 1;
	}
	if (i == (int)ft_strlen(line))
	{
		free(line);
		return (true);
	}
	return (false);
}

void	minishell_loop(t_data *data)
{
	while (1)
	{
		init_signals_prompt();
		data->line = readline("minishell$ ");
		if (!data->line)
		{
			ft_putstr_fd("exit\n", 2);
			free_all(data, g_exit_status, true);
		}
		if (empty_line(data->line))
			continue ;
		add_history(data->line);
		if (!parse_line(data))
			continue ;
		else
			executecommand(data);
		free_token(&data->token);
		free_cmd(&data->cmd);
		free(data->line);
	}
}

int	main(int argc, char *argv[], char **envp)
{
	t_data	data;

	if (!isatty(1))
		return (ft_putstr_fd("Error output is not a terminal\n", 2), 1);
	if (!isatty(0))
		return (ft_putstr_fd("Error intput is not a terminal\n", 2), 1);
	init_data(&data, argc, argv, envp);
	if (!envp || !*envp || !envp[0])
		emptyenv(&data, &data.env);
	else
		parse_env(envp, &data);
	execshell(&data, &data.env);
	minishell_loop(&data);
	free_all(&data, 0, true);
	clear_history();
	return (0);
}


