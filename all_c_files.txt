/* ======= fichier: ./Exec/builtin.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/26 17:07:27 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/03 20:29:03 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	isbuiltin(t_data *data)
{
	char	*cmd;

	if (!data || !data->cmd || !data->cmd->name)
		return (0);
	cmd = data->cmd->name;
	return (ft_strcmp(cmd, "echo") == 0 || ft_strcmp(cmd, "pwd") == 0
		|| ft_strcmp(cmd, "env") == 0 || ft_strcmp(cmd, "exit") == 0
		|| ft_strcmp(cmd, "cd") == 0 || ft_strcmp(cmd, "export") == 0
		|| ft_strcmp(cmd, "unset") == 0);
}

void	exec_builtin(t_data *data)
{
	t_cmd	*cmd;
	t_env	*env_list;

	env_list = data->env;
	cmd = data->cmd;
	if (!cmd || !cmd->name)
		exit(0);
	if (ft_strcmp(cmd->name, "echo") == 0)
		builtin_echo(data);
	else if (ft_strcmp(cmd->name, "pwd") == 0)
		builtin_pwd();
	else if (ft_strcmp(cmd->name, "env") == 0)
		builtin_env(env_list, data);
	else if (ft_strcmp(cmd->name, "exit") == 0)
		builtin_exit(data);
	else if (ft_strcmp(cmd->name, "cd") == 0)
		builtin_cd(cmd->args[1], data);
	else if (ft_strcmp(cmd->name, "export") == 0)
		builtin_export(data, &env_list, cmd);
	else if (ft_strcmp(cmd->name, "unset") == 0)
		builtin_unset(&env_list, cmd);
}

void	builtin_pwd(void)
{
	char	*cwd;

	cwd = getcwd(NULL, 0);
	if (cwd)
	{
		printf("%s\n", cwd);
		free(cwd);
	}
	else
		perror("cwd");
}

int	is_numeric(const char *str)
{
	int	i;

	i = 0;

	if (!str)
		return (0);
	if (str[i] == '+' || str[i] == '-')
		i++;
	if (!str[i])
		return (0);
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}

void	builtin_exit(t_data *data)
{
	char **args = data->cmd->args;

	printf("exit\n");
	if (args[1])
	{
		if (!is_numeric(args[1]))
		{
			// argument non numérique
			printf("bash: exit: %s: numeric argument required\n", args[1]);
			free_all(data, 255, true); // quitter avec code 255
		}
		else if (args[2])
		{
			// trop d'arguments
			printf("bash: exit: too many arguments\n");
			data->exit_code = 1;
			return;
		}
		else
		{
			// argument unique numérique → quitter avec ce code
			int exit_code = ft_atoi(args[1]) % 256;
			if (exit_code < 0)
				exit_code += 256;
			free_all(data, exit_code, true);
		}
	}
	else
	{
		// pas d'arguments → quitter avec le code courant
		free_all(data, data->exit_code, true);
	}
}

void	builtin_env( t_env *env_list, t_data *data)
{
	t_cmd	*cmd;

	cmd = data->cmd;
	if (cmd->args[1] && ft_strcmp(cmd->args[1], "env") != 0)
		printf("env: ‘%s’: No such file or directory\n", cmd->args[1]);
	else
	{
		while (env_list)
		{
			if (env_list->value != NULL)
				printf("%s=%s\n", env_list->name, env_list->value);
			env_list = env_list->next;
		}
		printf("_=/usr/bin/env\n");
	}
}


/* ======= fichier: ./Exec/builtin3.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin3.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 22:18:28 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/03 20:33:59 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	antislash(const char *str, int i)
{
	int	j;
	int	b_slash;

	j = 0;
	b_slash = 0;
	while (str[i] == '\\')
	{
		b_slash++;
		i++;
	}
	while (j < (b_slash / 2))
	{
		ft_putchar ('\\');
		j++;
	}
	if (b_slash % 2 == 1)
	{
		if (str[i] != '\0')
			ft_putchar(str[i++]);
	}
	else if (str[i] != '\0')
		ft_putchar(str[i++]);
	return (i);
}

void	print_antislash(const char *str)
{
	int	i;

	i = 0;
	while (str[i])
		i = antislash(str, i);
}

void	echo(t_env *env_list, int i, t_cmd *cmd, t_data *data)
{
	(void)data;
	(void)env_list;
	if ( cmd->args[i][0] == ';')
		return ;
	if (cmd->args[i][0] == '\\')
	{
		if (cmd->args[i][1] >= 'a' && cmd->args[i][1] <= 'z')
			printf("%s", &cmd->args[i][1]);
		else
			print_antislash(&cmd->args[i][1]);
	}
	else
		printf("%s", cmd->args[i]);
}

int	check_newline(t_data *data, char **args, int *i)
{
	int	j;
	int	newline ;

	newline = 1;
	while (args[*i] && args[*i][0] == '-' && args[*i][1] == 'n')
	{
		j = 1;
		while (args[*i][j] == 'n')
		{
			j++;
			data->exit_code = 0;
		}
		if (args[*i][j] != '\0')
			break ;
		newline = 0;
		(*i)++;
	}
	return (newline);
}

void	builtin_echo(t_data *data)
{
	int		i;
	int		newline;
	char	**args;
	t_cmd	*cmd;
	t_env	*env_list;

	cmd = data->cmd;
	env_list = data->env;
	i = 1;
	args = cmd->args;
	newline = check_newline(data, args, &i);
	while (args[i])
	{
		echo(env_list, i, cmd, data);
		if (cmd->args[i + 1])
			printf(" ");
		i++;
	}
	if (newline)
	{
		printf("\n");
		data->exit_code = 0;
	}
}


/* ======= fichier: ./Exec/builtin2.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin2.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/21 21:42:28 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/03 20:32:01 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	emptyenv(t_data *data, t_env **env_list)
{
	char	*cwd;

	cwd = getcwd(NULL, 0);
	if (!cwd)
		malloc_failed(data);
	if (*env_list == NULL)
	{
		add_env_var(data, env_list, "PWD", cwd);
		add_env_var(data, env_list, "SHLVL", "1");
	}
	free(cwd);
}

void	built_path(char *newpath, t_data *data)
{
	char		cwd[1024];
	struct stat	sb;

	if (access(newpath, F_OK) != 0)
	{
		printf("cd: %s: No such file or directory\n", newpath);
		data->exit_code = 1;
		return ;
	}
	if (stat(newpath, &sb) != 0 || !S_ISDIR(sb.st_mode))
	{
		printf("bash: cd: %s: Not a directory\n", newpath);
		data->exit_code = 1;
		return ;
	}
	if (access(newpath, X_OK) != 0)
	{
		printf("bash: cd: %s: Permission denied\n", newpath);
		data->exit_code = 126;
		return ;
	}
	getcwd(cwd, sizeof(cwd));
	chdir(newpath);
	updatepwd(data, &data->env, cwd);
}

/* void	builtin_cd(char *newpath, t_data *data)
{
	const char	*home;
	char		*expanded_path ;
	t_env		*old;

	expanded_path = NULL;
	if (newpath == NULL)
	{
		newpath = getenv("HOME");
		chdir("/home");
	}
	if (newpath[0] == '-')
	{
		old = find_env_var((data->env), "OLDPWD");
		if (!old || !old->value)
		{
			printf("cd: OLDPWD not set\n");
			return ;
		}
		printf("%s\n", old->value);
		newpath = old->value;
	}
	if (newpath[0] == '~')
	{
		home = getenv("HOME");
		if (home)
		{
			expanded_path = malloc(ft_strlen(home) + ft_strlen(newpath));
			ft_strcpy(expanded_path, home);
			ft_strcat(expanded_path, newpath + 1);
			newpath = expanded_path;
		}
	}
	built_path(newpath, data);
	free(expanded_path);
} */

void	builtin_cd(char *newpath, t_data *data)
{
	const char	*home;
	char		*expanded_path = NULL;
	t_env		*old;
	bool		must_free = false;

	if (newpath == NULL)
	{
		home = getenv("HOME");
		if (!home)
		{
			printf("cd: HOME not set\n");
			data->exit_code = 1;
			return ;
		}
		newpath = (char *)home;
	}
	else if (newpath[0] == '-')
	{
		old = find_env_var(data->env, "OLDPWD");
		if (!old || !old->value)
		{
			printf("cd: OLDPWD not set\n");
			data->exit_code = 1;
			return ;
		}
		printf("%s\n", old->value);
		newpath = ft_strdup(old->value);
		if (!newpath)
			malloc_failed(data);
		must_free = true;
	}
	else if (newpath[0] == '~')
	{
		home = getenv("HOME");
		if (!home)
		{
			printf("cd: HOME not set\n");
			data->exit_code = 1;
			return ;
		}
		expanded_path = malloc(ft_strlen(home) + ft_strlen(newpath));
		if (!expanded_path)
			malloc_failed(data);
		ft_strcpy(expanded_path, home);
		ft_strcat(expanded_path, newpath + 1);
		newpath = expanded_path;
		must_free = true;
	}
	built_path(newpath, data);
	if (must_free)
		free(newpath);
}

void	unset(t_env **env_list, char *name )
{
	t_env	*current;
	t_env	*previous;

	current = *env_list;
	previous = NULL;
	while (current)
	{
		if (ft_strcmp(current->name, name) == 0)
		{
			if (previous)
				previous->next = current->next;
			else
				*env_list = current->next;
			free(current->name);
			free(current->value);
			free(current);
			break ;
		}
		previous = current;
		current = current->next;
	}
}

void	builtin_unset(t_env **env_list, t_cmd *cmd)
{
	char	*name;
	int		i;

	if (!cmd->args || !cmd->args[1])
		return ;
	i = 1;
	while (cmd->args[i])
	{
		name = cmd->args[i];
		unset(env_list, name);
		i++;
	}
}


/* ======= fichier: ./Exec/envp.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   envp.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 15:43:10 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/03 20:37:30 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

char	*getenvp(t_env *list, char *name)
{
	while (list)
	{
		if (ft_strcmp(list->name, name) == 0)
			return (list->value);
		list = list->next;
	}
	return (NULL);
}

/* void	add_env_var(t_data *data, t_env **env_list, char *name, char *value)
{
	t_env	*new_var;
	t_env	*tmp;

	new_var = malloc(sizeof(t_env));
	if (!new_var)
	{
		free(name);
		malloc_failed(data);
	}
	new_var->name = ft_strdup(name);
	new_var->value = ft_strdup(value);
	if (!new_var->name || !new_var->value)
	{
		free(name);
		free_env(&new_var);
		malloc_failed(data);
	}
	new_var->next = NULL;
	if (!*env_list)
	{
		*env_list = new_var;
		return ;
	}
	tmp = *env_list;
	while (tmp->next)
		tmp = tmp->next;
	tmp->next = new_var;
} */

void	add_env_var(t_data *data, t_env **env_list, char *name, char *value)
{
	t_env	*new_var;
	t_env	*tmp;

	new_var = malloc(sizeof(t_env));
	if (!new_var)
	{
		free(name);
		malloc_failed(data);
	}
	new_var->name = ft_strdup(name);
	new_var->value = ft_strdup(value);
	if (!new_var->name || (value != NULL && !new_var->value))
	{
		free(name);
		free_env(&new_var);
		malloc_failed(data);
	}
	new_var->next = NULL;
	if (!*env_list)
	{
		*env_list = new_var;
		return ;
	}
	tmp = *env_list;
	while (tmp->next)
		tmp = tmp->next;
	tmp->next = new_var;
}
/* 
void	copy_env(t_env *tmp, int count, char **envp)
{
	int		i;
	size_t	len;

	i = 0;
	while (i < count)
	{
		if (tmp->value == NULL)
		{
			tmp = tmp->next;
			continue ; // ne pas inclure cette variable dans envp
		}
		len = ft_strlen(tmp->name) + ft_strlen(tmp->value) + 2;
		envp[i] = malloc(len);
		if (!envp[i])
		{
			perror("malloc");
			exit(EXIT_FAILURE);
		}
		ft_strcpy(envp[i], tmp->name);
		ft_strcat(envp[i], "=");
		ft_strcat(envp[i], tmp->value);
		tmp = tmp->next;
		i++;
	}
} */

/* int count_env_vars(t_env *env_list)
{
    int count = 0;
    while (env_list)
    {
        if (env_list->value != NULL)
            count++;
        env_list = env_list->next;
    }
    return count;
}

char **convert_env(t_env *env_list)
{
    int count = count_env_vars(env_list);
    char **envp = malloc((count + 1) * sizeof(char *));
    int i = 0;
    
    if (!envp)
    {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    while (env_list)
    {
        if (env_list->value != NULL)
        {
            size_t len = ft_strlen(env_list->name) + ft_strlen(env_list->value) + 2;
            envp[i] = malloc(len);
            if (!envp[i])
            {
                perror("malloc");
                exit(EXIT_FAILURE);
            }
            ft_strcpy(envp[i], env_list->name);
            ft_strcat(envp[i], "=");
            ft_strcat(envp[i], env_list->value);
            i++;
        }
        env_list = env_list->next;
    }
    envp[i] = NULL;
    return envp;
} */


void	copy_env(t_env *tmp, char **envir)
{
	int		i = 0;
	size_t	len;

	while (tmp)
	{
		if (tmp->value != NULL)
		{
			len = ft_strlen(tmp->name) + ft_strlen(tmp->value) + 2;
			envir[i] = malloc(len);
			if (!envir[i])
			{
				perror("malloc");
				exit(EXIT_FAILURE);
			}
			ft_strcpy(envir[i], tmp->name);
			ft_strcat(envir[i], "=");
			ft_strcat(envir[i], tmp->value);
			i++;
		}
		tmp = tmp->next;
	}
}

char	**convert_env(t_env *env_list)
{
	int		count;
	t_env	*tmp;
	char	**envir;

	tmp = env_list;
	count = 0;
	while (tmp)
	{
		if (tmp->value != NULL)
			count++;
		tmp = tmp->next;
	} 
	envir = malloc((count + 1) * sizeof(char *));
	if (!envir)
	{
		perror("malloc");
		exit(EXIT_FAILURE);
	}
	tmp = env_list;
	copy_env(env_list, envir);
	envir[count] = NULL;
	return (envir);
}
void	parse_env(char **envp, t_data *data)
{
	int		i;
	char	*name;
	char	*value;
	char	*equal_pos;

	i = 0;
	while (envp[i])
	{
		equal_pos = ft_strchr(envp[i], '=');
		if (!equal_pos)
		{
			i++;
			continue ;
		}
		name = ft_substr(envp[i], 0, equal_pos - envp[i]);
		if (!name)
			malloc_failed(data);
		value = equal_pos + 1;
		add_env_var(data, &data->env, name, value);
		free(name);
		i++;
	}
}


/* ======= fichier: ./Exec/exec.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/20 20:57:16 by aboutale          #+#    #+#             */
/*   Updated: 2025/05/14 19:33:51 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	parent_and_wait(int status, char *path, t_data *data, pid_t pid)
{
	waitpid(pid, &status, 0);
	free(path);
	if (data->cmd->fd_in != STDIN_FILENO)
		close(data->cmd->fd_in);
	if (data->cmd->fd_out != STDOUT_FILENO)
		close(data->cmd->fd_out);
	if (WIFEXITED(status))
		data->exit_code = WEXITSTATUS(status);
	else if (WIFSIGNALED(status))
		data->exit_code = 128 + WTERMSIG(status);
}

void	extern_childprocess(t_data *data, char *path, t_env *env, char **args)
{
/* 	if (data->cmd->fd_in != -1 && data->cmd->fd_in != STDIN_FILENO)
	{
		dup2(data->cmd->fd_in, STDIN_FILENO);
		close(data->cmd->fd_in);
	}
	if (data->cmd->fd_out != -1 && data->cmd->fd_out != STDOUT_FILENO)
	{
		dup2(data->cmd->fd_out, STDOUT_FILENO);
		close(data->cmd->fd_out);
	} */
	if (data->cmd->fd_in != STDIN_FILENO)
	{
		dup2(data->cmd->fd_in, STDIN_FILENO);
		close(data->cmd->fd_in);
	}
	if (data->cmd->fd_out != STDOUT_FILENO)
	{
		dup2(data->cmd->fd_out, STDOUT_FILENO);
		close(data->cmd->fd_out);
	}
	execve(path, args, convert_env(env));
	perror("execve");
	exit(127);
}

bool	is_a_directory(char *path, char **args, t_data *data)
{
	struct stat	sb;

	if (!args[0] || args[0][0] == '\0')
	{
		printf("minishell: command not found\n");
		data->exit_code = 127;
		free(path);
		return true;
	}

	if (stat(path, &sb) == 0 && S_ISDIR(sb.st_mode))
	{
		printf("bash: %s: Is a directory\n", args[0]);
		free(path);
		data->exit_code = 126;
		return (true);
	}
	return (false);
}

bool	have_no_permission(char *cmd_path, t_data *data)
{
	if (access(cmd_path, F_OK) != 0)
	{
		printf("minishell: %s: No such file or directory\n", cmd_path);
		data->exit_code = 127;
		return true;
	}
	if (access(cmd_path, X_OK) != 0)
	{
		printf("minishell: %s: Permission denied\n", cmd_path);
		data->exit_code = 126;
		return true;
	}
	return false;
}

void	exec_extern_command(char **args, t_env *env, t_data *data)
{
	pid_t		pid;
	int			status;
	char		*path;

	status = 0;
	if (!args || !args[0])
	{
		data->exit_code = 0;
		return ;
	} 
	if (ft_strchr(args[0], '/'))
		path = ft_strdup(args[0]);
	else
		path = getpath(args[0], data);
	if (!path)
	{
		if (ft_strcmp(args[0], "\\n") == 0)
		{
			printf("n : command not found \n");
			data->exit_code = 127;
		}
		else
			printf("%s: command not found\n", args[0]);
		free(path);
		data->exit_code = 127;
		return ;
	}
	if (is_a_directory(path, args, data))
	{
		free(path);
		return ;
	}
	if (have_no_permission(path, data))
		return ;
	pid = fork();
	if (pid == -1)
		return (perror("fork"), data->exit_code = 1, free(path));
	if (pid == 0)
		extern_childprocess(data, path, env, args);
	else
		parent_and_wait(status, path, data, pid);
}


/* ======= fichier: ./Exec/export.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/20 20:41:49 by aboutale          #+#    #+#             */
/*   Updated: 2025/05/07 00:30:55 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	validate_export_name(char *name)
{
	int	i;

	i = 1;
	if (!name)
		return (0);
	if (!ft_isalpha(name[0]) && name[0] != '_')
		return (0);
	while (name[i])
	{
		if (!ft_isalnum(name[i]) && name[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

char	*extract_name(char *arg)
{
	char	*sign;

	if (arg[0] == '\0')
		return (NULL);
	if (!arg || *arg == '\0')
		return (NULL);
	sign = ft_strchr(arg, '=');
	if (arg[0] == '=') //|| ft_strchr(arg, ' ') != NULL
		return (NULL);
	/* if (sign == arg)
		return (ft_strdup("")); */
	/*  if (arg[0] == '=')
		return (ft_strdup(""));  */
	if (!sign)
		return (ft_strdup(arg));
	return (ft_substr(arg, 0, sign - arg));
}

char	*extract_value(char *arg)
{
	char	*sign;

	if (!arg || *arg == '\0')
		return (NULL);
	sign = ft_strchr(arg, '=');
	if (!sign)
		return (NULL);
	if (*(sign + 1) == '\0')
		return (ft_strdup(""));
	return (ft_strdup(sign + 1));
}

t_env	*copyenvlist(t_data *data, t_env *env_list)
{
	t_env	*newlist;
	t_env	*current;

	newlist = NULL;
	current = env_list;
	while (current)
	{
		add_env_var(data, &newlist, current->name, current->value);
		current = current->next;
	}
	return (newlist);
}

void	built_export(t_data *data, t_env *env_list)
{
	t_env	*sortedlist;
	t_env	*current;

	sortedlist = copyenvlist(data, env_list);
	sort_env(&sortedlist);
	current = sortedlist;
	while (current)
	{
		if (ft_strcmp(current->name, "_") != 0)
		{
			if (current->value == NULL /*  || current->value[0] == '\0'  */)
				printf("declare -x %s\n", current->name);
			//else if (current->value[0] == '\0')
			//	printf("declare -x %s=\"\"\n", current->name);
			else
				printf("declare -x %s=\"%s\"\n", current->name, current->value);
		}
		current = current->next;
	}
	free_env_list(sortedlist);
}


/* ======= fichier: ./Exec/envp2.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   envp2.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/23 21:13:05 by aboutale          #+#    #+#             */
/*   Updated: 2025/04/29 19:42:32 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	swap_env(t_env *a, t_env *b)
{
	char	*tmp;

	tmp = a->name;
	a->name = b->name;
	b->name = tmp;
	tmp = a->value;
	a->value = b->value;
	b->value = tmp;
}

void	sort_env(t_env **env_list)
{
	t_env	*current ;
	t_env	*nextnode;
	int		swap;

	swap = 1;
	while (swap)
	{
		swap = 0;
		current = *env_list;
		while (current->next)
		{
			nextnode = current->next;
			if (ft_strcmp(current->name, nextnode->name) > 0)
			{
				swap_env(current, nextnode);
				swap = 1;
			}
			current = current->next;
		}
	}
}

void	free_env_list(t_env *env_list)
{
	t_env	*tmp;

	while (env_list)
	{
		tmp = env_list;
		free(tmp->name);
		free(tmp->value);
		env_list = env_list->next;
		free(tmp);
	}
}

void	builtin_export(t_data *data, t_env **env_list, t_cmd *cmd)
{
	if (!cmd->args[1])
		built_export(data, *env_list);
	else
		built_export2(data, env_list, cmd->args);
}


/* ======= fichier: ./Exec/exec2.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec2.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 22:20:48 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/03 21:02:04 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	exec_builtin_redirection(t_data *data)
{
	int	saved_in;
	int	saved_out;

	saved_in = dup(STDIN_FILENO);
	saved_out = dup(STDOUT_FILENO);
	if (data->cmd->fd_in != STDIN_FILENO)
	{
		dup2(data->cmd->fd_in, STDIN_FILENO);
		close(data->cmd->fd_in);
	}
	if (data->cmd->fd_out != STDOUT_FILENO)
	{
		dup2(data->cmd->fd_out, STDOUT_FILENO);
		close(data->cmd->fd_out);
	}
	exec_builtin(data);
	dup2(saved_in, STDIN_FILENO);
	dup2(saved_out, STDOUT_FILENO);
	close(saved_in);
	close(saved_out);
}

void	executecommand(t_data *data)
{
	if (!data || !data->line || !data->env)
		return ;
	if (data->cmd->next)
		exec_pipe(data->cmd, data);
	else if (isbuiltin(data))
	{
		if (!ft_strcmp(data->cmd->args[0], "exit"))
			exit (0);
		else
			exec_builtin_redirection(data);
	}
	else if (data->cmd->args && data->cmd->args[0])
		exec_extern_command(data->cmd->args, data->env, data);
	else
	{
		//exec_extern_command(data->cmd->args, data->env, data);
		if (data->cmd->fd_in != STDIN_FILENO)
			close(data->cmd->fd_in);
		if (data->cmd->fd_out != STDOUT_FILENO)
			close(data->cmd->fd_out);
	}
}

t_env	*find_env_var(t_env *env_list, char *name)
{
	while (env_list != NULL)
	{
		if (ft_strcmp(env_list->name, name) == 0)
			return (env_list);
		env_list = env_list->next;
	}
	return (NULL);
}

int	ft_atoi_safe(const char *str, int *out)
{
	int			i;
	int			sign;
	int			digit;
	long long	res;

	i = 0;
	sign = 1;
	res = 0;
	if (!str || !*str)
		return (0);
	while (str[i] == ' ' || (str[i] >= 9 && str[i] <= 13))
		i++;
	if (str[i] == '+' || str[i] == '-')
		if (str[i++] == '-')
			sign = -1;
	while (str[i] >= '0' && str[i] <= '9')
	{
		digit = str[i++] - '0';
		res = res * 10 + digit;
		if (sign == 1 && res > INT_MAX)
			return (0);
		if (sign == -1 && -res < INT_MIN)
			return (0);
	}
	*out = res * sign;
	return (1);
}

void shlvl_verification(t_env *shlvl, int *lvl)
{
	if (ft_isnumeric(shlvl->value) && ft_atoi_safe(shlvl->value, lvl))
	{
		if (*lvl >= 999)
		{
			(*lvl)++;
			printf("warning: shell level (%d)", *lvl);
			printf(" too high, resetting to 1\n");
			*lvl = 1;
		}
		else if (*lvl < 0)
			*lvl = 0;
		else
			(*lvl)++;
	}
}

void	execshell(t_data *data, t_env **env_list)
{
	t_env	*shlvl;
	int		lvl;
	char	*new_val;

	shlvl = find_env_var(*env_list, "SHLVL");
	if (!shlvl)
	{
		add_env_var(data, env_list, "SHLVL", "1");
		return ;
	}
	lvl = 1;
	shlvl_verification(shlvl, &lvl);
	new_val = ft_itoa(lvl);
	if (!new_val)
		malloc_failed(data);
	free(shlvl->value);
	shlvl->value = new_val;
}


/* ======= fichier: ./Exec/export2.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export2.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/21 21:47:12 by aboutale          #+#    #+#             */
/*   Updated: 2025/05/07 00:30:59 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

/* void update_env_var(t_env **env_list, char *name, char *value)
{
    t_env *current = *env_list;

	printf("update_env_var: name='%s', value='%s'\n", name, value ? value : "NULL");
    while (current)
    {
        if (ft_strcmp(current->name, name) == 0)
        {
            free(current->value);
            if (value)
                current->value = ft_strdup(value);
            else
                current->value = ft_strdup("");  // valeur vide si NULL
            return;
        }
        current = current->next;
    }
} */

void	update_env_var(t_env **env_list, char *name, char *value)
{
	t_env	*current;

	current = *env_list;
	while (current)
	{
		/* if (current->value == NULL)
			return ; */
		if (ft_strcmp(current->name, name) == 0)
		{
			free(current->value);
			current->value = ft_strdup(value);
			return ;
		}
		current = current->next;
	}
}

/* void	updatepwd(t_data *data, t_env **env_list, char *oldpath)
{
	char	newpwd[100];
	t_env	*old;
	t_env	*pwd;
	(void)data;

	if (!getcwd(newpwd, sizeof(newpwd)))
	{
		perror("cd: error retrieving current directory");
		data->exit_code = 1;
		old = find_env_var(*env_list, "OLDPWD");
		if (old)
		{
			free(old->value);
			old->value = ft_strdup(oldpath);
		}
		return ;
	}
	old = find_env_var(*env_list, "OLDPWD");
	if (old)
	{
		free(old->value);
		old->value = ft_strdup(oldpath);
	}
	pwd = find_env_var(*env_list, "PWD");
	if (pwd)
	{
		free(pwd->value);
		pwd->value = ft_strdup(newpwd);
	}
} */
void updatepwd(t_data *data, t_env **env_list, char *oldpath)
{
    char *newpwd;
    t_env *old;
    t_env *pwd;

    newpwd = getcwd(NULL, 0);
    if (!newpwd)
    {
        perror("cd: error retrieving current directory");
        data->exit_code = 1;
        old = find_env_var(*env_list, "OLDPWD");
        if (old)
        {
            free(old->value);
            old->value = ft_strdup(oldpath);
        }
        return;
    }
    old = find_env_var(*env_list, "OLDPWD");
    if (old)
    {
        free(old->value);
        old->value = ft_strdup(oldpath);
    }
    pwd = find_env_var(*env_list, "PWD");
    if (pwd)
    {
        free(pwd->value);
        pwd->value = strdup(newpwd);
    }
    free(newpwd);
}



/* t_env	*get_env_var_by_name(t_env *env_list, char *name)
{
	while (env_list)
	{
		if (ft_strcmp(env_list->name, name) == 0)
			return env_list;  // retourne la variable complète, même si value == NULL
		env_list = env_list->next;
	}
	return (NULL);
} */


/* void	existing_value(t_data *data, t_env **env_list, char *name, char *value)
{
	char	*existing_value;

	existing_value = getenvp(*env_list, name);
	if (existing_value)
	{
		if (value != NULL)
			update_env_var(env_list, name, value);
	}
	else
	{
		if (value)
			add_env_var(data, env_list, name, value);
		else
			add_env_var(data, env_list, name, NULL);

	}
}  */
/* 
void	existing_value(t_data *data, t_env **env_list, char *name, char *value)
{
	t_env	*existing_value;

	existing_value = get_env_var_by_name(*env_list, name);
	if (existing_value)
	{
		if (value != NULL)
			update_env_var(env_list, name, value);
	}
	else
		add_env_var(data, env_list, name, value);
} */

void existing_value(t_data *data, t_env **env_list, char *name, char *value)
{
   char *existing_value = getenvp(*env_list, name);
    if (existing_value)
    {
        if (value == NULL)
            value = ft_strdup(""); // valeur vide mais non NULL
        update_env_var(env_list, name, value);
    }
    else
    {
        if (value == NULL)
            value = ft_strdup(NULL);
        add_env_var(data, env_list, name, value);
    }
} 



void	increment_and_free(int *i, char *value, char *name)
{
	free(name);
	free(value);
	(*i)++;
}

int	is_concatenation(char *str)
{
	char	*eq;

	eq = ft_strchr(str, '=');
	if (!eq || eq == str)
		return (0);
	return (*(eq - 1) == '+');
}

int	loop(t_env *current, char *new_value, char *var_name)
{
	char	*joined;

	while (current)
	{
		if (ft_strcmp(current->name, var_name) == 0)
		{
			joined = ft_strjoin(current->value, new_value);
			free(current->value);
			current->value = joined;
			return (1);
		}
		current = current->next;
	}
	return (0);
}

void	ft_concatenation(char *str, t_env **env_list, t_data *data)
{
	char	*equal_sign;
	char	*var_name;
	char	*new_value;
	t_env	*current;

	var_name = NULL;
	new_value = NULL;
	equal_sign = ft_strchr(str, '=');
	if (equal_sign && equal_sign > str && *(equal_sign - 1) == '+')
	{
		var_name = ft_substr(str, 0, equal_sign - str - 1);
		new_value = ft_strdup(equal_sign + 1);
	}
	current = *env_list;
	if (!loop(current, new_value, var_name))
		existing_value(data, env_list, var_name, new_value);
	free(var_name);
	free(new_value);
}

/* char	*exp_value(char *expand_value, t_env *env_list)
{
	char *name;
	char *value;

	if (!expand_value)
		return (NULL);
	if (expand_value[0] == '$')
	{
		name = expand_value +1;
		value = getenvp(env_list, name);
		if (!value)
			return (ft_strdup(""));
		return(ft_strdup(value));
	}
	return(ft_strdup(expand_value));

}  */

void	built_export2(t_data *data, t_env **env_list, char **args)
{
	int		i;
	char	*name;
	char	*value;
	//char 	*expand_value;

	i = 1;
	while (args[i])
	{
		if (is_concatenation(args[i]))
		{
			ft_concatenation(args[i], env_list, data);
			i++;
			continue ;
		}
		//expand_value = extract_value(args[i]);
		name = extract_name(args[i]);
		value = extract_value(args[i]);
		//value = exp_value(expand_value, *env_list);
	/* 	if (expand_value)
			value = exp_value(expand_value, *env_list);
		else
			value = NULL;
		free(expand_value); */
		if (!name)
		{
			printf("bash: export: `%s': not a valid identifier\n", args[i]);
			data->exit_code = 1;
			increment_and_free(&i, value, name);
			continue ;
		}
		if (!validate_export_name(name))
		{
			printf("bash: export: `%s': not a valid identifier\n", args[i]);
			data->exit_code = 1;
			increment_and_free(&i, value, name);
			continue ;
		}
		existing_value(data, env_list, name, value);
		increment_and_free(&i, value, name);
	}
}


/* ======= fichier: ./Exec/getpath.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   getpath.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/26 21:43:31 by aboutale          #+#    #+#             */
/*   Updated: 2025/05/07 00:35:09 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

char	*get_absolute_path(char *cmd)
{
	if (cmd[0] == '/' || cmd[0] == '.')
	{
		if (access(cmd, X_OK) == 0)
			return (ft_strdup(cmd));
	}
	return (NULL);
}

char	*find_cmd_path(char *cmd, t_env *env_list)
{
	char	*path;
	char	**token;
	char	*full_path;
	int		i;

	i = 0;
	path = getenvp(env_list, "PATH");
	if (!path)
		return (free(path), NULL);
	token = ft_split(path, ':');
	while (token[i])
	{
		full_path = malloc(ft_strlen(token[i]) + ft_strlen(cmd) + 2);
		if (!full_path)
			break ;
		ft_strcpy(full_path, token[i]);
		ft_strcat(full_path, "/");
		ft_strcat(full_path, cmd);
		if (access(full_path, X_OK) == 0)
			return (free_tab(token), full_path);
		free(full_path);
		i++;
	}
	free_tab(token);
	return (NULL);
}

char	*getpath(char *cmd, t_data *data)
{
	char	*fullpath;

	fullpath = get_absolute_path(cmd);
	if (fullpath)
		return (fullpath);

	fullpath = find_cmd_path(cmd, data->env);
	if (!fullpath)
		data->exit_code = 127;

	return (fullpath);
}


/* ======= fichier: ./Exec/pipe.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/22 16:20:22 by aboutale          #+#    #+#             */
/*   Updated: 2025/05/20 17:35:39 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	input_and_output(t_data *data, int prev_fd, int pipe_fd[2])
{
	if (data->cmd->fd_in != STDIN_FILENO)
	{
		dup2(data->cmd->fd_in, STDIN_FILENO);
		close(data->cmd->fd_in);
	}
	else if (prev_fd != -1)
	{
		dup2(prev_fd, STDIN_FILENO);
		close(prev_fd);
	}
	if (data->cmd->fd_out != STDOUT_FILENO)
	{
		dup2(data->cmd->fd_out, STDOUT_FILENO);
		close(data->cmd->fd_out);
	}
	else if (data->cmd->next)
	{
		dup2(pipe_fd[1], STDOUT_FILENO);
		close(pipe_fd[1]);
	}
}
void	handle_command_error(char *cmd, char *msg, int exit_code, t_data *data)
{
	if (data)
		data->exit_code = exit_code;
	ft_putstr_fd("minishell: ", 2);
	if (cmd)
	{
		ft_putstr_fd(cmd, 2);
		ft_putstr_fd(": ", 2);
	}
	ft_putstr_fd(msg, 2);
	exit(exit_code);
}

void	childprocess(t_data *data, int prev_fd, int pipe_fd[2])
{

	if (!isbuiltin(data))
	{
		//if (!getpath(data->cmd->args[0], data))
		char *path = getpath(data->cmd->args[0], data);
		if (!path)
			handle_command_error(data->cmd->args[0], "command not found\n",
			127, data);
	} 
	input_and_output(data, prev_fd, pipe_fd);
	if (prev_fd != -1)
		close(prev_fd);
	if (data->cmd->next)
	{
		close(pipe_fd[0]);
		close(pipe_fd[1]);
	}
	if (isbuiltin(data))
	{
		if (ft_strcmp(data->cmd->args[0], "exit") == 0)
			exit(0);
		else
			exec_builtin(data);
	}
	else
		exec_extern_command(data->cmd->args, data->env, data);
	exit(EXIT_SUCCESS);
}

void	parent_process(int *prev_fd, t_cmd **cmd, int *pipe_fd, t_data *data)
{
	int	status;

	if (*prev_fd != -1)
		close(*prev_fd);
	if ((*cmd)->next)
	{
		close(pipe_fd[1]);
		*prev_fd = pipe_fd[0];
	}
	else
		*prev_fd = -1;
	*cmd = (*cmd)->next;

	while (wait(&status) > 0)
	{
		if (WIFEXITED(status))
			data->exit_code = WEXITSTATUS(status);
		else if (WIFSIGNALED(status))
			data->exit_code = 128 + WTERMSIG(status);
	}
}

void	handle_error(char *message)
{
	ft_putstr_fd(message, 2);
	exit(EXIT_FAILURE);
}


void	exec_pipe(t_cmd *cmd, t_data *data)
{
	int		pipe_fd[2];
	pid_t	pid;
	int		prev_fd;

	while (cmd)
	{
		data->cmd = cmd;
		if (cmd->next && pipe(pipe_fd) == -1)
			handle_error("pipe failed\n");
		pid = fork();
		if (pid == -1)
			handle_error("fork error\n");
		if (pid == 0)
		{
			if (!isbuiltin(data))
			{
				char *path = getpath(cmd->args[0], data);
				if (!path)
					handle_command_error(cmd->args[0], "command not found\n",
						127, data);
			} 
		/* 	if (execve(path, cmd->args,convert_env(data->env)) == -1)
			{
   	 			printf("%s: command not found\n", cmd->args[0]);
    			exit(127);
			}   */
			childprocess(data, prev_fd, pipe_fd);
		}
		else
			parent_process(&prev_fd, &cmd, pipe_fd, data);
	}
	while (wait(NULL) > 0)
		;
}


/* ======= fichier: ./Libft/ft_strmapi.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strmapi.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 17:01:55 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/04 17:30:00 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
{
	char			*new_str;
	unsigned int	i;

	if (!s || !f)
		return (NULL);
	new_str = (char *)malloc((ft_strlen(s) + 1) * sizeof(char));
	if (!new_str)
		return (NULL);
	i = 0;
	while (s[i])
	{
		new_str[i] = f(i, s[i]);
		i++;
	}
	new_str[i] = '\0';
	return (new_str);
}


/* ======= fichier: ./Libft/ft_strncmp.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strncmp.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 17:18:47 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:26:14 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	while (n && *s1 && (*s1 == *s2))
	{
		s1++;
		s2++;
		n--;
	}
	if (n == 0)
		return (0);
	return ((unsigned char)(*s1) - (unsigned char)(*s2));
}

/*int main (void)
{
	char str1[] = "AZDe";
	char str2[] = "ABDe";

	int result = ft_strncmp(str1, str2, sizeof (str1));
	printf ("La comparaison de %s et de %s donne %d", str1, str2, result);
}*/


/* ======= fichier: ./Libft/ft_strnstr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strnstr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 10:16:45 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:26:24 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

char	*ft_strnstr(const char *big,	const char *little, size_t len)
{
	size_t	i;
	size_t	j;

	i = 0;
	if (*little == '\0')
		return ((char *)(big));
	while (big[i] != '\0' && i < len)
	{
		j = 0;
		while (big[j + i] == little[j] && (i + j) < len)
		{
			if (little [j + 1] == '\0')
				return ((char *)(&big[i]));
			j++;
		}
		i++;
	}
	return (0);
}

/*int	main(void)
{
	char str[] = "Bonjour tout le monde";
	char to_find[] = "toit";

	char *result = ft_strnstr(str, to_find, sizeof (str));
	if (result != 0)
		printf("Resultat :%s\n", result);
	else
		printf("Erreur.\n");
	return (0);
}*/


/* ======= fichier: ./Libft/ft_strrchr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strrchr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 11:47:37 by mlavry            #+#    #+#             */
/*   Updated: 2025/01/06 18:11:56 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

char	*ft_strrchr(const char *s, int c)
{
	char	*temp;

	temp = 0;
	while (*s)
	{
		if (*s == (unsigned char)c)
			temp = (char *)s;
		s++;
	}
	if ((unsigned char)c == '\0')
		return ((char *)s);
	return (temp);
}

/* int main(void)
{
    char str[] = "Hello, world!";
    char *result;

    result = ft_strrchr(str, 'o');
    if (result)
        printf("Last occurrence of 'o' found at: %s\n", result);
    else
        printf("'o' not found\n");

    return 0;
} */


/* ======= fichier: ./Libft/ft_strtrim.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strtrim.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 12:41:14 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/25 13:00:39 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static int	ft_is_in_set(char c, const char *set)
{
	while (*set)
	{
		if (c == *set)
			return (1);
		set++;
	}
	return (0);
}

char	*ft_strtrim(char const *s1, char const *set)
{
	int		start;
	int		end;
	char	*trimmed_str;
	int		i;

	start = 0;
	i = 0;
	if (!s1 || !set)
		return (NULL);
	while (s1[start] && ft_is_in_set(s1[start], set))
		start++;
	end = start;
	while (s1[end])
		end++;
	end--;
	while (end >= start && ft_is_in_set(s1[end], set))
		end--;
	trimmed_str = malloc(end - start + 2);
	if (!trimmed_str)
		return (NULL);
	while (start <= end)
		trimmed_str[i++] = s1[start++];
	trimmed_str[i] = '\0';
	return (trimmed_str);
}


/* ======= fichier: ./Libft/ft_substr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_substr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 17:21:34 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 18:19:47 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_substr(char const *s, unsigned int start, size_t len)
{
	char	*sub;
	size_t	s_len;

	if (!s)
		return (NULL);
	s_len = ft_strlen(s);
	if (start >= s_len)
		return (ft_strdup(""));
	if (start + len > s_len)
		len = s_len - start;
	sub = (char *)malloc(len + 1);
	if (!sub)
		return (NULL);
	ft_strlcpy(sub, s + start, len + 1);
	return (sub);
}

/*#include <stdio.h>

int main() {
    const char *original = "Hello, World!";
    char *substring = ft_substr(original, 7, 5); // Extrait "World"

    if (substring) {
        printf("Sous-chaîne : %s\n", substring);
        free(substring); // N'oublie pas de libérer la mémoire
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_tolower.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tolower.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 11:13:20 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/17 11:17:45 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_tolower(int c)
{
	if (c >= 'A' && c <= 'Z')
		c += 32;
	return (c);
}

/*int main(void)
{
    char test_chars[] = {'a', 'z', 'A', 'Z', '1', '!', 'm'};
    unsigned int i;

    printf("Testing ft_tolower function:\n\n");

    for (i = 0; i < sizeof(test_chars); i++)
    {
        char original = test_chars[i];
        char lower = ft_tolower(original);
        printf("Original: %c | Lower: %c\n", original, lower);
    }

    return (0);
}*/


/* ======= fichier: ./Libft/ft_toupper.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_toupper.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 10:43:00 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/17 11:05:18 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_toupper(int c)
{
	if (c >= 'a' && c <= 'z')
		c -= 32;
	return (c);
}

/*int main(void)
{
    char test_chars[] = {'a', 'z', 'A', 'Z', '1', '!', 'm'};
    unsigned int i;

    printf("Testing ft_toupper function:\n\n");

    for (i = 0; i < sizeof(test_chars); i++)
    {
        char original = test_chars[i];
        char upper = ft_toupper(original);
        printf("Original: %c | Upper: %c\n", original, upper);
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_lstnew_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 17:37:43 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/05 17:48:53 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstnew(void *content)
{
	t_list	*new_elem;

	new_elem = (t_list *)malloc(sizeof(t_list));
	if (!new_elem)
		return (NULL);
	new_elem->content = content;
	new_elem->next = NULL;
	return (new_elem);
}


/* ======= fichier: ./Libft/ft_printhexa.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printhexa.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/13 18:04:24 by mlavry            #+#    #+#             */
/*   Updated: 2024/12/18 14:15:22 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_hex_len(unsigned int num)
{
	int	len;

	len = 0;
	while (num != 0)
	{
		len++;
		num = num / 16;
	}
	return (len);
}

void	ft_put_hex(unsigned int num, const char format)
{
	if (num >= 16)
	{
		ft_put_hex(num / 16, format);
		ft_put_hex(num % 16, format);
	}
	else
	{
		if (num <= 9)
			ft_putchar(num + '0');
		else
		{
			if (format == 'x')
				ft_putchar(num - 10 + 'a');
			if (format == 'X')
				ft_putchar(num - 10 + 'A');
		}
	}
}

int	ft_print_hex(unsigned int num, const char format)
{
	if (num == 0)
		return (write(1, "0", 1));
	else
		ft_put_hex(num, format);
	return (ft_hex_len(num));
}


/* ======= fichier: ./Libft/ft_lstmap_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstmap_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 12:11:52 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/06 13:18:37 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))
{
	t_list	*new_lst;
	t_list	*new_node;
	void	*content;

	if (!lst || !f)
		return (NULL);
	new_lst = NULL;
	while (lst)
	{
		content = f(lst->content);
		new_node = ft_lstnew(content);
		if (!new_node)
		{
			if (content)
				del (content);
			ft_lstclear(&new_lst, del);
			return (NULL);
		}
		ft_lstadd_back(&new_lst, new_node);
		lst = lst->next;
	}
	return (new_lst);
}


/* ======= fichier: ./Libft/ft_lstsize_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstsize_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 18:19:35 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/05 18:24:56 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_lstsize(t_list *lst)
{
	int	count;

	count = 0;
	while (lst != NULL)
	{
		count++;
		lst = lst->next;
	}
	return (count);
}


/* ======= fichier: ./Libft/ft_memchr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 17:35:36 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:24:01 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

void	*ft_memchr(const void *s, int c, size_t n)
{
	const unsigned char	*ptr;
	size_t				i;

	ptr = (const unsigned char *) s;
	i = 0;
	while (i < n)
	{
		if (ptr[i] == (unsigned char) c)
		{
			return ((void *)(ptr + i));
		}
		i++;
	}
	return (0);
}

/*int	main(void)
{
	char	buffer[20] = "Bonjour";
	char	*result;

	result = ft_memchr(buffer, '5', sizeof(buffer) - 1);
	if (result != NULL)
		printf("Carac trouvé à l'adresse : %p, rest : %s\n", result, result);
	else
		printf("Caractère non trouvé.\n");
	return (0);
}*/


/* ======= fichier: ./Libft/ft_memcmp.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 09:55:30 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 15:58:01 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

int	ft_memcmp(const void *s1, const void *s2, size_t n)
{
	const unsigned char	*str1;
	const unsigned char	*str2;

	str1 = (const unsigned char *) s1;
	str2 = (const unsigned char *) s2;
	while (n)
	{
		if (*str1 != *str2)
			return (*str1 - *str2);
		str1++;
		str2++;
		n--;
	}
	return (0);
}

/*int main (void)
{
	char str1[] = "AZDe";
	char str2[] = "ABDe";

	int result = ft_memcmp(str1, str2, sizeof (str1));
	printf ("La comparaison de %s et de %s donne %d", str1, str2, result);
}*/


/* ======= fichier: ./Libft/ft_printnbr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printnbr.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/20 13:59:06 by mlavry            #+#    #+#             */
/*   Updated: 2024/12/18 14:15:33 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_printnbr(int n)
{
	int		len;
	char	*num;

	len = 0;
	num = ft_itoa(n);
	len = ft_printstr(num);
	free (num);
	return (len);
}

int	ft_uprintnbr(unsigned int n)
{
	int		len;
	char	*num;

	len = 0;
	if (n == 0)
		len += write(1, "0", 1);
	else
	{
		num = ft_uitoa(n);
		len += ft_printstr(num);
		free (num);
	}
	return (len);
}


/* ======= fichier: ./Libft/ft_lstiter_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstiter_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 12:02:41 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/06 12:08:35 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstiter(t_list *lst, void (*f)(void *))
{
	if (!lst || !f)
		return ;
	while (lst)
	{
		f (lst->content);
		lst = lst->next;
	}
}


/* ======= fichier: ./Libft/ft_lstlast_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstlast_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 18:29:01 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/05 18:36:30 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstlast(t_list *lst)
{
	if (!lst)
		return (NULL);
	while (lst->next != NULL)
	{
		lst = lst->next;
	}
	return (lst);
}


/* ======= fichier: ./Libft/ft_isdigit.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isdigit.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 10:39:28 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/15 10:50:20 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_isdigit(int c)
{
	return (c >= '0' && c <= '9');
}

/*int main()
{
    char chars[] = {'A', '0', '1', '*', '9', 'm'};
    int i;

    for (i = 0; i < 6; i++) {
        if (ft_isdigit(chars[i])) {
            printf("Le caractère '%c' est un chiffre.\n", chars[i]);
        }
		else {
        printf("Le caractère '%c' n'est pas un chiffre.\n", chars[i]);
        }
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_isalnum.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalnum.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 10:50:14 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/15 11:08:12 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_isalnum(int c)
{
	return ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
		|| (c >= '0' && c <= '9'));
}

/*int main()
{
    char chars[] = {'A', 'b', '1', '*', 'Z', ' '};
    int i;

    for (i = 0; i < 6; i++) {
        if (ft_isalnum(chars[i])) {
            printf("Le caractère '%c' est alphanumerique.\n", chars[i]);
        }
		else {
        printf("Le caractère '%c' n'est pas alphanumerique.\n", chars[i]);
        }
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_isprint.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isprint.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 11:51:33 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/15 12:02:04 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_isprint(int c)
{
	return (c >= 32 && c <= 126);
}

/*int main()
{
	char chars[] = {'A', '0', '1', '*', '\n', 'm'};
    int i;

    for (i = 0; i < 6; i++) {
        if (ft_isprint(chars[i])) {
            printf("Le caractère '%c' est imprimable.\n", chars[i]);
        }
		else {
        printf("Le caractère '%c' n'est pas imprimable.\n", chars[i]);
        }
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_printf.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/12 14:49:15 by mlavry            #+#    #+#             */
/*   Updated: 2024/12/18 14:14:57 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_printchar(int c)
{
	write(1, &c, 1);
	return (1);
}

int	ft_printpercent(void)
{
	write(1, "%", 1);
	return (1);
}

int	ft_format(va_list args, const char format)
{
	int	printlen;

	printlen = 0;
	if (format == 'c')
		printlen += ft_printchar(va_arg(args, int));
	else if (format == 's')
		printlen += ft_printstr(va_arg(args, char *));
	else if (format == 'p')
		printlen += ft_printptr(va_arg(args, unsigned long));
	else if (format == 'd')
		printlen += ft_printnbr(va_arg(args, int));
	else if (format == 'i')
		printlen += ft_printnbr(va_arg(args, int));
	else if (format == 'u')
		printlen += ft_uprintnbr(va_arg(args, unsigned int));
	else if (format == 'x' || format == 'X')
		printlen += ft_print_hex(va_arg(args, unsigned int), format);
	else if (format == '%')
		printlen += ft_printpercent();
	return (printlen);
}

int	ft_printf(const char *str, ...)
{
	va_list	args;
	int		i;
	int		printlen;

	i = 0;
	printlen = 0;
	va_start(args, str);
	while (str[i])
	{
		if (str[i] == '%')
		{
			printlen += ft_format(args, str[i + 1]);
			i++;
		}
		else
			printlen += ft_printchar(str[i]);
		i++;
	}
	va_end(args);
	return (printlen);
}

/* #include <stdio.h>

int main()
{
	int ptr;

	ptr = 1;

	printf("%%\n");
	ft_printf("%%\n");


} */


/* ======= fichier: ./Libft/ft_memset.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 14:41:09 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:25:02 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

void	*ft_memset(void *s, int c, size_t n)
{
	unsigned char	*ptr;

	ptr = (unsigned char *) s;
	while (n)
	{
		*ptr = (unsigned char) c;
		n--;
		ptr++;
	}
	return (s);
}

/*int	main(void)
{
	char	buffer[20];

	ft_memset(buffer, '0', sizeof (buffer) - 1);
	buffer[19] = '\0';
	printf("Tableau cree : %s\n", buffer);
	return (0);
}*/


/* ======= fichier: ./Libft/ft_memmove.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memmove.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 12:12:40 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:24:48 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

void	*ft_memmove(void *dest, const void *src, size_t n)
{
	unsigned char		*d;
	const unsigned char	*s;
	size_t				i;

	d = (unsigned char *) dest;
	s = (const unsigned char *) src;
	if (d > s)
	{
		while (n > 0)
		{
			n--;
			d[n] = s[n];
		}
	}
	if (d < s)
	{
		i = 0;
		while (i < n)
		{
			d[i] = s[i];
			i++;
		}
	}
	return (dest);
}

/*int main (void)
{
	char src[] = "Salut !";
	char dest[50];

	ft_memmove(dest, src, sizeof (src) - 1);
	dest[sizeof (src) - 1] = '\0';
	printf ("Tableau de dest : %s\n", dest);
	return (0);
}*/


/* ======= fichier: ./Libft/ft_lstadd_front_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_front_bonus.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 17:59:08 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/05 18:16:51 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstadd_front(t_list **lst, t_list *new)
{
	if (!new)
		return ;
	new->next = *lst;
	*lst = new;
}


/* ======= fichier: ./Libft/ft_lstclear_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstclear_bonus.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 11:33:19 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/06 11:56:03 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstclear(t_list **lst, void (*del)(void *))
{
	t_list	*next;

	if (!lst || !del)
		return ;
	while (*lst)
	{
		next = (*lst)->next;
		del((*lst)->content);
		free(*lst);
		*lst = next;
	}
	*lst = NULL;
}


/* ======= fichier: ./Libft/ft_printptr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printptr.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/13 16:08:26 by mlavry            #+#    #+#             */
/*   Updated: 2024/12/18 14:15:51 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putchar(char c)
{
	write (1, &c, 1);
}

int	ft_ptr_len(unsigned long num)
{
	int	len;

	len = 0;
	if (num == 0)
		return (1);
	while (num != 0)
	{
		len++;
		num = num / 16;
	}
	return (len);
}

void	ft_put_ptr(unsigned long num)
{
	if (num >= 16)
	{
		ft_put_ptr(num / 16);
		ft_put_ptr(num % 16);
	}
	else
	{
		if (num <= 9)
			ft_putchar(num + '0');
		else
			ft_putchar(num - 10 + 'a');
	}
}

int	ft_printptr(unsigned long ptr)
{
	int	printlen;

	printlen = 0;
	if (ptr == 0)
		printlen += write(1, "(nil)", 5);
	else
	{
		printlen += write(1, "0x", 2);
		ft_put_ptr(ptr);
		printlen += ft_ptr_len(ptr);
	}
	return (printlen);
}


/* ======= fichier: ./Libft/ft_printstr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printstr.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 18:18:57 by mlavry            #+#    #+#             */
/*   Updated: 2025/03/19 18:24:29 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_printstr(char *s)
{
	int	i;

	i = 0;
	if (!s)
	{
		ft_putstr_fd("(null)", 1);
		return (6);
	}
	while (s[i])
	{
		write (1, &s[i], 1);
		i++;
	}
	return (i);
}


/* ======= fichier: ./Libft/ft_putchar_fd.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 18:09:35 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/04 18:15:29 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putchar_fd(char c, int fd)
{
	write(fd, &c, 1);
}


/* ======= fichier: ./Libft/ft_putendl_fd.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 18:24:29 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/04 18:27:06 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putendl_fd(char *s, int fd)
{
	while (*s != '\0')
	{
		write(fd, s, 1);
		s++;
	}
	write(fd, "\n", 1);
}


/* ======= fichier: ./Libft/ft_putnbr_fd.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 18:28:34 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/04 18:35:52 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putnbr_fd(int n, int fd)
{
	if (n == -2147483648)
	{
		write(fd, "-2147483648", 11);
		return ;
	}
	if (n < 0)
	{
		ft_putchar_fd('-', fd);
		n = -n;
	}
	if (n >= 10)
	{
		ft_putnbr_fd(n / 10, fd);
	}
	ft_putchar_fd(n % 10 + '0', fd);
}


/* ======= fichier: ./Libft/ft_putstr_fd.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 18:18:57 by mlavry            #+#    #+#             */
/*   Updated: 2025/03/18 18:31:40 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putstr_fd(char *s, int fd)
{
	write(fd, s, ft_strlen(s));
}


/* ======= fichier: ./Libft/ft_split.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 13:04:43 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/05 16:49:38 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static char	**free_array(char **ptr, int i)
{
	while (i > 0)
	{
		i--;
		free(ptr[i]);
	}
	free(ptr);
	return (0);
}

static int	ft_count_words(char const *str, char c)
{
	int	i;
	int	count;

	i = 0;
	count = 0;
	while (str[i] != '\0')
	{
		if (str[i] == c)
			i++;
		else
		{
			count++;
			while (str[i] && str[i] != c)
				i++;
		}
	}
	return (count);
}

static char	*ft_putword(char *word, char const *s, int i, int word_len)
{
	int	j;

	j = 0;
	while (word_len > 0)
	{
		word[j] = s[i - word_len];
		j++;
		word_len--;
	}
	word[j] = '\0';
	return (word);
}

static char	**ft_split_words(char const *s, char c, char **s2, int num_words)
{
	int	i;
	int	word;
	int	word_len;

	i = 0;
	word = 0;
	while (word < num_words)
	{
		while (s[i] && s[i] == c)
			i++;
		word_len = 0;
		while (s[i + word_len] && s[i + word_len] != c)
			word_len++;
		s2[word] = (char *)malloc(sizeof(char) * (word_len + 1));
		if (!s2[word])
			return (free_array(s2, word));
		ft_putword(s2[word], s, i + word_len, word_len);
		i += word_len;
		word++;
	}
	s2[word] = 0;
	return (s2);
}

char	**ft_split(char const *s, char c)
{
	char			**s2;
	unsigned int	num_words;

	if (!s)
		return (0);
	num_words = ft_count_words(s, c);
	s2 = (char **)malloc(sizeof(char *) * (num_words + 1));
	if (!s2)
		return (0);
	return (ft_split_words(s, c, s2, num_words));
}


/* ======= fichier: ./Libft/ft_strchr.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 11:19:53 by mlavry            #+#    #+#             */
/*   Updated: 2025/01/06 18:34:30 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

char	*ft_strchr(const char *s, int c)
{
	while (*s)
	{
		if (*s == (unsigned char)c)
			return ((char *)s);
		s++;
	}
	if ((unsigned char)c == '\0')
		return ((char *)s);
	return (0);
}

/* int main(void)
{
    char str[] = "Hello, world!";
    char *result;

    result = ft_strchr(str, 'o');
    if (result)
        printf("First occurrence of 'o' found at: %s\n", result);
    else
        printf("'o' not found\n");

    return 0;
} */


/* ======= fichier: ./Libft/ft_lstdelone_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstdelone_bonus.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 11:22:41 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/06 11:29:32 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstdelone(t_list *lst, void (*del)(void *))
{
	if (!lst || !del)
		return ;
	del (lst->content);
	free (lst);
}


/* ======= fichier: ./Libft/ft_isalpha.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalpha.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 10:25:50 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/15 10:46:23 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_isalpha(int c)
{
	return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));
}

/*int main()
{
    char chars[] = {'A', 'b', '1', '*', 'Z', 'm'};
    int i;

    for (i = 0; i < 6; i++) {
        if (ft_isalpha(chars[i])) {
            printf("Le caractère '%c' est une lettre alphabétique.\n", chars[i]);
        }
		else {
        printf("Le caractère '%c' n'est pas alphabétique.\n", chars[i]);
        }
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_isascii.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isascii.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 11:21:25 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/15 11:50:51 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_isascii(int c)
{
	return (c >= 0 && c <= 127);
}

/*int main()
{
    char chars[] = {'126', 'b', '1', '*', '132', '-4'};
    int i;

    for (i = 0; i < 6; i++) {
        if (ft_isascii(chars[i])) {
            printf("Le caractère '%c' est un caractere ascii.\n", chars[i]);
        }
		else {
        printf("Le caractère '%c' n'est pas un caractere ascii.\n", chars[i]);
        }
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_util_convert.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_util_convert.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 15:25:28 by mlavry            #+#    #+#             */
/*   Updated: 2024/12/18 14:25:48 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

/* static int	numlen(int n)
{
	int	len;

	len = 1;
	if (n < 0)
		len++;
	while (n / 10 != 0)
	{
		len++;
		n /= 10;
	}
	return (len);
} */

int	u_numlen(unsigned int n)
{
	int	len;

	len = 0;
	while (n != 0)
	{
		len++;
		n /= 10;
	}
	return (len);
}

/* char	*ft_itoa(int n)
{
	unsigned int	num;
	int				len;
	char			*str;

	len = numlen(n);
	str = (char *)malloc(len + 1);
	if (!str)
		return (NULL);
	str [len--] = '\0';
	if (n < 0)
	{
		str [0] = '-';
		num = -n;
	}
	else
		num = n;
	while (num >= 10)
	{
		str [len--] = (num % 10) + '0';
		num /= 10;
	}
	str [len] = num + '0';
	return (str);
} */

char	*ft_uitoa(unsigned int n)
{
	int				len;
	char			*str;

	len = u_numlen(n);
	str = (char *)malloc(len + 1);
	if (!str)
		return (0);
	str [len--] = '\0';
	while (n != 0)
	{
		str [len] = n % 10 + 48;
		n = n / 10;
		len--;
	}
	return (str);
}


/* ======= fichier: ./Libft/ft_atoi.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 10:46:15 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/03 00:49:00 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>

int	ft_atoi(const char *nptr)
{
	int	i;
	int	result;
	int	sign;

	i = 0;
	result = 0;
	sign = 0;
	while (nptr[i] == ' ' || (nptr[i] >= 9 && nptr[i] <= 13))
		i++;
	if (nptr[i] == '+' || nptr[i] == '-')
	{
		if (nptr[i] == '-')
			sign++;
		i++;
	}
	while (nptr[i] >= '0' && nptr[i] <= '9')
	{
		result = result * 10 + (nptr[i] - '0');
		i++;
	}
	if (sign % 2 != 0)
		result = -result;
	return (result);
}

/* int	main(void)
{
	char str1[] = " -1234ab567";
	char str2[] = "  569999999999999+7b8";
	char *str3 = "0";

	int num1 = ft_atoi(str1);
	int num2 = ft_atoi(str2);
	int num3 = ft_atoi(str3);
	int num4 = ft_atoi("00001");
	int num5 = ft_atoi("214748364");

	printf("num1 = %d\n", num1);
	printf("num2 = %d\n", num2);
	printf("num3 = %d\n", num3);
	printf("num4 = %d\n", num4);
	printf("num5 = %d\n", num5);

	return (0);
} */


/* ======= fichier: ./Libft/ft_bzero.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bzero.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 15:42:21 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/02 16:36:42 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

void	ft_bzero(void *s, size_t n)
{
	unsigned char	*ptr;

	if (!s && n > 0)
		return ;
	ptr = (unsigned char *)s;
	while (n)
	{
		*ptr = 0;
		n--;
		ptr++;
	}
}

/*int main (void)
{
	char buffer[5] = "1234";
	int i = 0;
	ft_bzero(buffer, sizeof(buffer));
	while (i < 5)
	{
		printf("%d", buffer[i]);
		i++;
	}
	return (0);
}*/


/* ======= fichier: ./Libft/ft_strdup.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 18:24:22 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/02 16:56:09 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

char	*ft_strdup(const char *s)
{
	char	*dest;
	int		i;
	int		len;

	len = 0;
	if (!s)
		return (NULL);
	while (s[len])
		len++;
	dest = (char *)malloc((len + 1) * sizeof(char));
	if (!dest)
		return (0);
	i = 0;
	while (i < len)
	{
		dest[i] = s[i];
		i++;
	}
	dest[i] = '\0';
	return (dest);
}

/*int main(void)
{
    char *original = "Bonjour";
    char *copie = ft_strdup(original);

    if (copie != NULL) {
        printf("Copie : %s\n", copie);
        free(copie);
    } else {
        printf("Échec de la duplication de la chaîne.\n");
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_striteri.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_striteri.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 17:34:42 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/04 18:07:21 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_striteri(char *s, void (*f)(unsigned int, char*))
{
	unsigned int	i;

	if (!s || !f)
		return ;
	i = 0;
	while (s[i])
	{
		f(i, &s[i]);
		i++;
	}
}


/* ======= fichier: ./Libft/ft_strjoin.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 18:26:06 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/21 15:50:45 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strjoin(char const *s1, char const *s2)
{
	char	*result;
	char	*start;
	size_t	len1;
	size_t	len2;

	if (!s1 || !s2)
		return (NULL);
	len1 = 0;
	while (s1[len1])
		len1++;
	len2 = 0;
	while (s2[len2])
		len2++;
	result = (char *)malloc(len1 + len2 + 1);
	if (!result)
		return (NULL);
	start = result;
	while (*s1)
		*result++ = *s1++;
	while (*s2)
		*result++ = *s2++;
	*result = '\0';
	return (start);
}

/*#include <stdio.h>

int main() {
    const char *str1 = "Hello, ";
    const char *str2 = "world!";
    char *result = ft_strjoin(str1, str2);

    if (result) {
        printf("%s\n", result); // Affiche "Hello, world!"
        free(result); // N'oublie pas de libérer la mémoire allouée
    }

    return 0;
}*/


/* ======= fichier: ./Libft/ft_lstadd_back_bonus.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_back_bonus.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 18:42:48 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/05 19:11:14 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstadd_back(t_list **lst, t_list *new)
{
	t_list	*current;

	if (!lst || !new)
		return ;
	if (!*lst)
	{
		*lst = new;
		return ;
	}
	current = *lst;
	while (current->next != NULL)
	{
		current = current->next;
	}
	current->next = new;
}


/* ======= fichier: ./Libft/ft_itoa.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 15:25:28 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/04 16:57:21 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static int	numlen(int n)
{
	int	len;

	len = 1;
	if (n < 0)
		len++;
	while (n / 10 != 0)
	{
		len++;
		n /= 10;
	}
	return (len);
}

char	*ft_itoa(int n)
{
	unsigned int	num;
	int				len;
	char			*str;

	len = numlen(n);
	str = (char *)malloc(len + 1);
	if (!str)
		return (NULL);
	str [len--] = '\0';
	if (n < 0)
	{
		str [0] = '-';
		num = -n;
	}
	else
		num = n;
	while (num >= 10)
	{
		str [len--] = (num % 10) + '0';
		num /= 10;
	}
	str [len] = num + '0';
	return (str);
}


/* ======= fichier: ./Libft/ft_memcpy.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcpy.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 16:25:30 by mlavry            #+#    #+#             */
/*   Updated: 2025/05/28 14:35:00 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

void	*ft_memcpy(void *dest, const void *src, size_t n)
{
	unsigned char		*d;
	const unsigned char	*s;

	d = (unsigned char *)dest;
	s = (const unsigned char *)src;
	while (n--)
		*d++ = *s++;
	return (dest);
}

/*int main (void)
{
	char src[] = "Bonjour5646546468";
	char dest[50];

	ft_memcpy(dest, src, sizeof (src) - 1);
	dest[sizeof (src) - 1] = '\0';
	printf("Tableau de dest : %s\n", dest);
	return (0);
}*/


/* ======= fichier: ./Libft/ft_calloc.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 17:41:41 by mlavry            #+#    #+#             */
/*   Updated: 2024/11/21 14:38:56 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

void	*ft_calloc(size_t n, size_t size)
{
	void			*ptr;
	size_t			total_size;
	unsigned char	*final;

	total_size = n * size;
	if (n != 0 && total_size / n != size)
		return (0);
	ptr = malloc(total_size);
	if (ptr == 0)
		return (0);
	final = (unsigned char *)ptr;
	while (total_size)
	{
		*final = 0;
		total_size--;
		final++;
	}
	return (ptr);
}

/*int main(void)
{
    int *arr;
    size_t n = 5;
    size_t size = sizeof(int);

    arr = (int *)ft_calloc(n, size);

    if (arr == NULL)
    {
        printf("Allocation échouée\n");
        return (1);
    }

    printf("Contenu du tableau alloué et initialisé à zéro :\n");
    for (size_t i = 0; i < n; i++)
    {
        printf("arr[%zu] = %d\n", i, arr[i]);
    }

    free(arr);

    return 0;
}*/


/* ======= fichier: ./Libft/ft_strlcat.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcat.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 17:37:09 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:25:28 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

size_t	ft_strlcat(char *dst, const char *src, size_t size)
{
	size_t	i;
	size_t	dst_len;
	size_t	src_len;

	dst_len = 0;
	src_len = 0;
	while (dst[dst_len] != '\0' && dst_len < size)
		dst_len++;
	while (src[src_len] != '\0')
		src_len++;
	if (size <= dst_len)
		return (size + src_len);
	i = 0;
	while (src[i] != '\0' && dst_len + i < size - 1)
	{
		dst[dst_len + i] = src[i];
		i++;
	}
	dst[dst_len + i] = '\0';
	return (dst_len + src_len);
}

/*int main (void)
{
	char dst[50] = "Bonjour";
	char src[] = " ou pas";
	size_t result = ft_strlcat(dst, src, 16);
	printf("Resultat : %zu\n", result);
	printf("Chaine : %s\n", dst);
	return (0);
}*/


/* ======= fichier: ./Libft/ft_strlcpy.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcpy.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 12:35:18 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:25:43 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

size_t	ft_strlcpy(char *dst, const char *src, size_t size)
{
	size_t	i;
	size_t	len;

	i = 0;
	len = 0;
	while (src[len] != '\0')
	{
		len ++;
	}
	if (size > 0)
	{
		while (i < size - 1 && src[i] != '\0')
		{
			dst[i] = src[i];
			i++;
		}
		dst[i] = '\0';
	}
	return (len);
}

/*int main (void)
{
	char src[] = "AAAABC !";
	char dest[20];
	size_t	result = ft_strlcpy(dest, src, sizeof src);
	printf("Source : %s\n", src);
	printf("Dest : %s\n", dest);
	printf("Resultat : %zu\n", result);
}*/


/* ======= fichier: ./Libft/ft_strlen.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlen.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <taaikiazerolier@gmail.com>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 14:13:34 by mlavry            #+#    #+#             */
/*   Updated: 2024/10/23 14:25:57 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include <stdio.h>
#include "libft.h"

size_t	ft_strlen(const char *s)
{
	int	i;

	i = 0;
	while (s[i] != '\0')
	{
		i++;
	}
	return (i);
}

/*int main(void)
{
	char phrase[] = "Boji";
	int result = ft_strlen(phrase);
	printf("La chaine comporte %d caracteres.\n", result);
}*/


/* ======= fichier: ./Parsing/expand.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 21:50:04 by aboutale          #+#    #+#             */
/*   Updated: 2025/06/03 16:07:52 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	dollar_exit(t_data *data, char **src, char **res, int *len_buf)
{
	char	*nbr;

	nbr = ft_itoa(data->exit_code);
	if (!nbr)
		return (0);
	if (!str_append(res, len_buf, nbr))
	{
		free(nbr);
		return (0);
	}
	free(nbr);
	*src += 2;
	return (1);
}

int	dollar_var(t_data *data, char **src, char **res, int *len_buf)
{
	size_t	i;
	char	*key;
	char	*value;

	i = 1;
	while ((*src)[i] && (ft_isalnum((*src)[i]) || (*src)[i] == '_'))
		i++;
	if (i <= 1)
		return (0);
	key = ft_substr(*src + 1, 0, i - 1);
	if (!key)
		malloc_failed(data);
	value = getenvp(data->env, key);
	free(key);
	if (value && !str_append(res, len_buf, value))
		malloc_failed(data);
	*src += i;
	return (1);
}

void	check_dollars(t_data *data, char **src, char **res, int *len_buf)
{
	if ((*src)[1] == '?')
	{
		if (!dollar_exit(data, src, res, len_buf))
			malloc_failed(data);
		return ;
	}
	if (dollar_var(data, src, res, len_buf))
		return ;
	if (!char_append(res, len_buf, *(*src)))
		malloc_failed(data);
	(*src)++;
}

int	check_quote_dollars(char **src)
{
	int	i;

	i = 1;
	if (is_quoted((*src)[i]))
	{
		(*src)++;
		return (1);
	}
	if (ft_isdigit((*src)[i]))
	{
		(*src) += 2;
		return (1);
	}
	return (0);
}

void	replace_dollars(t_data *data)
{
	char	*src;
	char	*res;
	int		len_buf;
	bool	sq;
	bool	dq;

	src = data->line;
	res = ft_strdup("");
	if (!res)
		malloc_failed(data);
	len_buf = 0;
	sq = false;
	dq = false;
	while (*src)
	{
		quote_choice(&sq, &dq, *src);
		if (*src == '$' && !dq)
		{
			if (check_quote_dollars(&src))
				continue ;
		}
		if (*src == '$' && !sq)
		{
			check_dollars(data, &src, &res, &len_buf);
			continue ;
		}
		if (!char_append(&res, &len_buf, *src))
			malloc_failed(data);
		src++;
	}
	free(data->line);
	data->line = res;
}

/* ======= fichier: ./Parsing/stock_tokens.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stock_tokens.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/22 20:48:09 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/04 21:27:49 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

static void	init_var(int pos[3], bool *sq, bool *dq)
{
	*sq = false;
	*dq = false;
	pos[0] = 0;
	pos[1] = 0;
	pos[2] = 0;
}

char *	handle_dq_joined(char *line, char *old_chain, bool *dq, int *pos)
{
	char	*temp;
	char	*res;
	bool	sq = false;

	temp = NULL;
	pos[1]++;
	pos[0] = pos[1];
	*dq = true;
	quote_choice(&sq, dq, line[pos[1]]);
	while (line[pos[1]] && *dq)
	{
		pos[1]++;
		quote_choice(&sq, dq, line[pos[1]]);
	}
	if (pos[1] > pos[0])
		temp = ft_substr(line, pos[0], pos[1] - pos[0]);
	pos[1]++;
	while (is_quoted(line[pos[1]]) && is_quoted(line[pos[1] + 1])
		&& line[pos[1]] == line[pos[1] + 1])
		pos[1] = pos[1] + 2;
	if (temp)
	{
		res = ft_strjoin(old_chain, temp);
		if (!is_space(line[pos[1]])
			&& !is_operator(line[pos[1]]))
			res = check_next(line, res, pos);
	}
	else
		return (old_chain);
	pos[0] = pos[1];
	return (res);
}

char *	handle_sq_joined(char *line, char *old_chain, bool *sq, int *pos)
{
	char	*temp;
	char	*res;
	bool	dq = false;

	temp = NULL;
	pos[1]++;
	pos[0] = pos[1];
	*sq = true;
	quote_choice(sq, &dq, line[pos[1]]);
	while (line[pos[1]] && *sq)
	{
		pos[1]++;
		quote_choice(sq, &dq, line[pos[1]]);
	}
	if (pos[1] > pos[0])
		temp = ft_substr(line, pos[0], pos[1] - pos[0]);
	pos[1]++;
	while (is_quoted(line[pos[1]]) && is_quoted(line[pos[1] + 1])
		&& line[pos[1]] == line[pos[1] + 1])
		pos[1] = pos[1] + 2;
	if (temp)
	{
		res = ft_strjoin(old_chain, temp);
		if (!is_space(line[pos[1]])
			&& !is_operator(line[pos[1]]))
			res = check_next(line, res, pos);
	}
	else
		return (old_chain);
	pos[0] = pos[1];
	return (res);
}

char	*handle_chain_joined(char *line, char *old_chain, int *pos)
{
	char	*temp;
	char	*res;
	bool	dq = false;
	bool	sq = false;

	temp = NULL;
	pos[0] = pos[1];
	quote_choice(&sq, &dq, line[pos[1]]);
	while (line[pos[1]] && !sq && !dq && !is_space(line[pos[1]])
		&& !is_operator(line[pos[1]]))
	{
		pos[1]++;
		quote_choice(&sq, &dq, line[pos[1]]);
	}
	if (pos[1] > pos[0])
		temp = ft_substr(line, pos[0], pos[1] - pos[0]);
	while (is_quoted(line[pos[1]]) && is_quoted(line[pos[1] + 1])
		&& line[pos[1]] == line[pos[1] + 1])
		pos[1] = pos[1] + 2;
	if (temp)
	{
		res = ft_strjoin(old_chain, temp);
		if (!is_space(line[pos[1]])
			&& !is_operator(line[pos[1]]))
			res = check_next(line, res, pos);
	}
	else
		return (old_chain);
	pos[0] = pos[1];
	return (res);
}

int	handle_sq(char *line, char **tokens, bool *sq, int *pos)
{
	char	*temp;
	bool	dq = false;

	temp = NULL;
	if (!*sq)
		return (0);
	pos[1]++;
	pos[0] = pos[1];
	if (is_operator(line[pos[1]]) && check_operators(line, tokens, pos))
	{
		pos[1]++;
		(*sq) = false;
		return (1);
	}
	quote_choice(sq, &dq, line[pos[1]]);
	while (line[pos[1]] && *sq)
	{
		pos[1]++;
		quote_choice(sq, &dq, line[pos[1]]);
	}
	if (pos[1] > pos[0])
		temp = ft_substr(line, pos[0], pos[1] - pos[0]);
	else
		temp = ft_strdup("");
	pos[1]++;
	while (is_quoted(line[pos[1]]) && is_quoted(line[pos[1] + 1])
		&& line[pos[1]] == line[pos[1] + 1])
		pos[1] = pos[1] + 2;
	if (!is_space(line[pos[1]])
		&& !is_operator(line[pos[1]]))
		temp = check_next(line, temp, pos);
	tokens[pos[2]++] = temp;
	pos[0] = pos[1];
	return (1);
}

int	handle_dq(char *line, char **tokens, bool *dq, int *pos)
{
	char	*temp;
	bool	sq = false;

	temp = NULL;
	if (!*dq)
		return (0);
	pos[1]++;
	pos[0] = pos[1];
	if (is_operator(line[pos[1]]) && check_operators(line, tokens, pos))
	{
		pos[1]++;
		(*dq) = false;
		return (1);
	}
	quote_choice(&sq, dq, line[pos[1]]);
	while (line[pos[1]] && *dq)
	{
		pos[1]++;
		quote_choice(&sq, dq, line[pos[1]]);
	}
	if (pos[1] > pos[0])
		temp = ft_substr(line, pos[0], pos[1] - pos[0]);
	else
		temp = ft_strdup("");
	pos[1]++;
	while (is_quoted(line[pos[1]]) && is_quoted(line[pos[1] + 1])
		&& line[pos[1]] == line[pos[1] + 1])
		pos[1] = pos[1] + 2;
	if (!is_space(line[pos[1]])
		&& !is_operator(line[pos[1]]))
		temp = check_next(line, temp, pos);
	tokens[pos[2]++] = temp;
	pos[0] = pos[1];
	return (1);
}

void	handle_operator(char *line, char **temp, int *pos)
{
	pos[0] = pos[1];
	while (line[pos[1]] == line[pos[0]])
		pos[1]++;
	*temp = ft_substr(line, pos[0], pos[1] - pos[0]);
	pos[0] = pos[1];
}

int	handle_unquoted(char *line, char **tokens, int *pos)
{
	char	*temp;
	bool	sq;
	bool	dq;

	temp = NULL;
	sq = false;
	dq = false;
	while (is_space(line[pos[1]]))
		pos[1]++;
	pos[0] = pos[1];
	quote_choice(&sq, &dq, line[pos[1]]);
	while (line[pos[1]] && !is_space(line[pos[1]]) && !is_operator(line[pos[1]])
		&& !sq && !dq)
	{
		pos[1]++;
		quote_choice(&sq, &dq, line[pos[1]]);
	}
	if (is_operator(line[pos[1]]))
	{
		if (pos[1] > pos[0])
			tokens[pos[2]++] = ft_substr(line, pos[0], pos[1] - pos[0]);
		handle_operator(line, &temp, pos);
		tokens[pos[2]++] = temp;
		return (1);
	}
	if (pos[1] > pos[0])
		temp = ft_substr(line, pos[0], pos[1] - pos[0]);
	if (is_quoted(line[pos[1]]) && is_operator(line[pos[1] + 1]))
	{
		pos[1]++;
		if (check_operators(line, tokens, pos))
		{
			quote_choice(&sq, &dq, line[pos[1]]);
			pos[1]++;
			return (1);
		}
	}
	if (!temp && line[pos[1]])
		temp = ft_strdup("");
	while (is_quoted(line[pos[1]]) && is_quoted(line[pos[1] + 1])
		&& line[pos[1]] == line[pos[1] + 1])
		pos[1] = pos[1] + 2;
	if (temp)
	{
		if (!is_space(line[pos[1]])
			&& !is_operator(line[pos[1]]))
			temp = check_next(line, temp, pos);
		tokens[pos[2]++] = temp;
	}
	pos[0] = pos[1];
	return (1);
}

char	*check_next(char *line, char *actual_chain, int *pos)
{
	bool	dq;
	bool	sq;
	char	*res;

	dq = false;
	sq = false;
	res = actual_chain;
	quote_choice(&sq, &dq, line[pos[1]]);
	if (sq)
		res = handle_sq_joined(line, actual_chain, &sq, pos);
	else if (dq)
		res = handle_dq_joined(line, actual_chain, &dq, pos);
	else
		res = handle_chain_joined(line, actual_chain, pos);
	return (res);
}

char	**line_to_token(char *line)
{
	char	**tokens;
	int		pos[3];
	bool	sq;
	bool	dq;

	init_var(pos, &sq, &dq);
	tokens = malloc(sizeof(char *) * 2000);
	if (!tokens)
		return (NULL);
	while (line[pos[1]])
	{
		quote_choice(&sq, &dq, line[pos[1]]);
		if (!sq && !dq && handle_unquoted(line, tokens, pos))
			continue ;
		if (handle_sq(line, tokens, &sq, pos)
			|| handle_dq(line, tokens, &dq, pos))
			continue ;
		pos[1]++;
	}
	tokens[pos[2]] = NULL;
	return (tokens);
}


/* ======= fichier: ./Parsing/token_to_commands.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_to_commands.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 17:28:02 by mlavry            #+#    #+#             */
/*   Updated: 2025/05/29 15:19:29 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	handle_cmd(t_cmd **head, t_cmd **cur, t_token *tokens)
{
	t_cmd	*new;

	new = ft_calloc (1, sizeof(t_cmd));
	if (!new)
		return (0);
	new->name = ft_strdup(tokens->str);
	if (!new->name)
	{
		free(new);
		return (0);
	}
	new->fd_in = STDIN_FILENO;
	new->fd_out = STDOUT_FILENO;
	if (!add_args(&new->args, new->name))
	{
		free(new->name);
		free(new);
		return (0);
	}
	if (!(*head))
		(*head) = new;
	else
		(*cur)->next = new;
	(*cur) = new;
	return (1);
}

int	handle_arg(t_cmd *cur, t_token *token)
{
	if (!cur)
		return (0);
	if (!add_args(&cur->args, token->str))
		return (0);
	return (1);
}

int	handle_pipe(t_token **tokens, t_cmd **cur)
{
	if (!cur || !*cur) // <-- AJOUT POUR ÉVITER LE CRASH
		return (0);
	if ((*tokens)->type == PIPE && (!(*tokens)->next))
	{
		printf("minishell: syntax error near unexpected token `|'\n");
		return (0);
	}
	if (!cur || !*cur)
		return (0);
	return (1);
}

int	handle_output(t_token **tokens, t_cmd **cur, t_data *data)
{
	if (!cur || !*cur) // <-- AJOUT POUR ÉVITER LE CRASH
		return (0);
	if ((*tokens)->type == OUTPUT
		&& (!(*tokens)->next || (*tokens)->next->type != ARG))
	{
		data->exit_code = 2;
		return (0);
	}
	if ((*tokens)->next && (*tokens)->next->type == ARG)
	{
		if ((*cur)->fd_out != STDOUT_FILENO && (*cur)->fd_out != -1)
    		close((*cur)->fd_out);

		(*cur)->fd_out = open((*tokens)->next->str,
				O_CREAT | O_WRONLY | O_TRUNC, 0644);
		if ((*cur)->fd_out < 0)
		{
			perror("open");
			return (0);
		}
		*tokens = (*tokens)->next;
	}
	return (1);
}

int	handle_input(t_token **tokens, t_cmd **cur, t_data *data)
{
	if (!cur || !*cur) // <-- AJOUT POUR ÉVITER LE CRASH
		return (0);
	if (tokens && ((*tokens)->type == INPUT)
		&& (!(*tokens)->next || (*tokens)->next->type != ARG))
	{
		data->exit_code = 2;
		return (0);
	}
	if ((*tokens)->next && (*tokens)->next->type == ARG)
	{
		if ((*cur)->fd_in != STDIN_FILENO)
    		close((*cur)->fd_in);
		(*cur)->fd_in = open((*tokens)->next->str, O_RDONLY);
		if ((*cur)->fd_in < 0)
		{
			perror("open");
			return (0);
		}
		*tokens = (*tokens)->next;
	}
	return (1);
}


int	handle_append(t_token **tokens, t_cmd **cur, t_data *data)
{
	if (!cur || !*cur) // <-- AJOUT POUR ÉVITER LE CRASH
		return (0);
	if ((*tokens)->type == APPEND
		&& ( !(*tokens)->prev || !(*tokens)->next || (*tokens)->next->type != ARG))
	{
		data->exit_code = 2;
		return (0);
	}
    if ((*tokens) && (*tokens)->type == APPEND
		&& (*tokens)->next && (*tokens)->next->type == ARG)
	{
		if ((*cur)->fd_out != STDOUT_FILENO && (*cur)->fd_out != -1)
			close((*cur)->fd_out);

		(*cur)->fd_out = open((*tokens)->next->str,
				O_WRONLY | O_CREAT | O_APPEND, 0644);
		if ((*cur)->fd_out < 0)
		{
			perror("open");
			return (0);
		}
		*tokens = (*tokens)->next;
	}
	return (1);
}

int handle_heredoc(t_token **tokens, t_cmd *cur, t_data *data)
{
	(void)data;
	if (!tokens || !*tokens || !(*tokens)->next)
		return 0;

	char *delimiter = (*tokens)->next->str;
	char *line;
	char tmp_filename[64];

	sprintf(tmp_filename, "/tmp/heredoc_%d.tmp", rand());
	int tmp_fd = open(tmp_filename, O_WRONLY | O_CREAT | O_TRUNC, 0600);
	if (tmp_fd == -1)
		return perror("open tmp"), 0;

	while (1)
	{
		write(1, "> ", 2);
		line = get_next_line(0);
		if (!line)
			break;

		// Supprime le \n pour comparer proprement
		line[strcspn(line, "\n")] = 0;

		if (strcmp(line, delimiter) == 0)
		{
			free(line);
			break;
		}

		write(tmp_fd, line, strlen(line));
		write(tmp_fd, "\n", 1); // réécris le \n
		free(line);
	}

	close(tmp_fd);

	// Redirige vers ce fichier
	if (cur->fd_in != STDIN_FILENO)
		close(cur->fd_in);
	cur->fd_in = open(tmp_filename, O_RDONLY);
	if (cur->fd_in == -1)
		return perror("open heredoc read"), 0;

	// NE PAS avancer les tokens ici
	return 1;
}


/* 
int	handle_heredoc(t_token **tokens, t_cmd **cur, t_data *data)
{
	char	*delimiter;
	int		pipefd[2];
	char	*line;

	if (!cur || !*cur || !tokens || !*tokens) // <-- AJOUT POUR ÉVITER LE CRASH
		return (0);
	if ((*tokens)->type == HEREDOC
		&& ( !(*tokens)->prev || !(*tokens)->next || (*tokens)->next->type != ARG))
	{
		data->exit_code = 2;
		return (0);
	}
	delimiter = (*tokens)->next->str;
//	if ((*cur)->fd_in != STDIN_FILENO)
	//	close((*cur)->fd_in);
	if (pipe(pipefd) == -1)
	{
    	perror("pipe");
    	return 0;
	}
	while(1)
	{
		write(1, "> ", 2);
		line = get_next_line(0);
		if (!line || ft_strncmp(line, delimiter, ft_strlen(delimiter)+1) == 0 
			 || ft_strcmp(line, ft_strcat(ft_strdup(delimiter), "\n")) == 0 )
		{
			free(line);
			break;
		}
		write(pipefd[1], line, ft_strlen(line));
		free(line);
	}
	close(pipefd[1]);
	(*cur)->fd_in = pipefd[0];
	*tokens = (*tokens)->next;
	return (1);
} */

int handle_output_redirect(t_token **tokens, t_cmd **cur, t_data *data)
{
	int	fd;
	int	flags;

	if (!*tokens || !(*tokens)->next /* || (*tokens)->next->type != ARG */)
		return (data->exit_code = 2, 0);

	char *filename = (*tokens)->next->str;

	if ((*tokens)->type == GREAT)
		flags = O_CREAT | O_WRONLY | O_TRUNC;
	else if ((*tokens)->type == DGREAT)
		flags = O_CREAT | O_WRONLY | O_APPEND;
	else
		return (0);

	fd = open(filename, flags, 0644);
	if (fd < 0)
	{
		perror("open");
		data->exit_code = 1;
		return (0);
	}
	if ((*cur)->fd_out != STDOUT_FILENO)
		close((*cur)->fd_out);
	(*cur)->fd_out = fd;
	*tokens = (*tokens)->next;
	if (*tokens)
		*tokens = (*tokens)->next;
	return (1);
}



bool is_type_token(t_token **tokens, t_cmd **head, t_cmd **cur, t_data *data)
{
	t_token *tok = *tokens;

	if (!tok)
		return false;

	if (tok->type == CMD)
	{
		bool ok = handle_cmd(head, cur, tok);
		*tokens = tok->next;
		return ok;
	}
	if (tok->type == ARG)
	{
		bool ok = handle_arg(*cur, tok);
		*tokens = tok->next;
		return ok;
	}
	 if (tok->type == GREAT || tok->type == DGREAT)
	 {
		printf("handle_output_redirect called for token type %d\n", tok->type);
        return handle_output_redirect(tokens, cur, data);
	 }

	if (tok->type == OUTPUT)
		return handle_output(tokens, cur, data);
	if (tok->type == INPUT)
		return handle_input(tokens, cur, data);
	if (tok->type == PIPE)
		return handle_pipe(tokens, cur);

	// ✅ Gérer plusieurs heredocs consécutifs
	while (*tokens && (*tokens)->type == HEREDOC)
	{
		if (!handle_heredoc(tokens, *cur, data))
			return false;

		// Avance de 2 tokens (HEREDOC + ARG)
		if (*tokens && (*tokens)->next)
			*tokens = (*tokens)->next->next;
		else
			break;
	}

	return true;
}






/* 
bool	is_type_token(t_token **tokens, t_cmd **head, t_cmd **cur, t_data *data)
{
	if ((*tokens)->type == CMD)
		return (handle_cmd(head, cur, *tokens));
	if ((*tokens)->type == ARG)
		return (handle_arg(*cur, *tokens));
	if ((*tokens)->type == OUTPUT)
		return (handle_output(tokens, cur, data));
	if ((*tokens)->type == INPUT)
		return (handle_input(tokens, cur, data));
	if ((*tokens)->type == PIPE)
		return (handle_pipe(tokens,cur));
 	while ((*tokens)->type == HEREDOC)
	{
       if( !handle_heredoc(tokens, cur, data))
			return false;
   		if (*tokens)
        	*tokens = (*tokens)->next;
		else
			break;
	}
	if ((*tokens)->type == GREAT || (*tokens)->type == DGREAT)
		return(handle_output_redirect(tokens,cur, data));
	if ((*tokens)->type == APPEND)
        return (handle_append(tokens ,cur, data)); 
	return (true);
}  */
/* bool	is_type_token(t_token **tokens, t_cmd **head, t_cmd **cur, t_data *data)
{
	t_token *tok = data->token;
	while (tok)
	{
		if (tok->type == HEREDOC)
		{
			if (!handle_heredoc(&tok, &data->cmd, data))
				break;
		}
		else if (tok->type == GREAT || tok->type == DGREAT)
		{
			if (!handle_output_redirect(&tok, &data->cmd, data))
				break;
		}
		else if (tok->type == CMD)
		{
			handle_cmd(head, cur, *tokens);
			tok = tok->next;
		}
		else if (tok->type == ARG)
		{
			handle_arg(*cur, *tokens);
			tok = tok->next;
		}
		else
			tok = tok->next;
	}
	return true;
} */





/* bool check_token_syntax(t_token *tokens, t_data *data)
{
    while (tokens)
    {
        // Vérifie si le token est un pipe
        if (tokens->type == PIPE)
        {
			 if (!tokens->prev || !tokens->next)
   			 {
        		printf("minishell: syntax error near unexpected token `|'\n");
        		data->exit_code = 2;
        		return false;
    		}
            // Si le token précédent est une redirection, c'est une erreur
            if (tokens->prev && (tokens->prev->type == OUTPUT || tokens->prev->type == HEREDOC || tokens->prev->type == APPEND || tokens->prev->type == INPUT))
            {
                printf("minishell: syntax error near unexpected token `%s'\n", tokens->str);
                data->exit_code = 2;
                return false;
            }
        }

        // Vérifie si le token est une redirection sans fichier suivant
        if ((tokens->type == OUTPUT || tokens->type == APPEND || tokens->type == INPUT) && (!tokens->next || tokens->next->type != ARG))
        {
            printf("minishell: syntax error near unexpected token `%s'\n", tokens->next ? tokens->next->str : "newline");
            data->exit_code = 2;
            return false;
        }

        tokens = tokens->next;
    }
    return true;
} */


t_cmd	*tokens_to_commands(t_token *tokens, t_data *data)
{
	t_cmd	*head;
	t_cmd	*cur;


	head = NULL;
	cur = NULL;
  	if (tokens && (tokens->type == OUTPUT || tokens->type == INPUT
 		|| tokens->type == APPEND || tokens->type == HEREDOC))
	{
    	cur = ft_calloc(1,sizeof(t_cmd));
		if (!cur)
			return NULL;
		cur->fd_in = STDIN_FILENO;
		cur->fd_out = STDOUT_FILENO;
		cur->name = ft_strdup("");
		head = cur;
	}  
	while (tokens)
	{
		if (!is_type_token (&tokens, &head, &cur, data))
			return (NULL);
		//tokens = tokens->next;
	}
	return (head);
}

/* void print_cmds(t_cmd *c)
{
    int idx;
    while (c)
    {
        printf("=== Command: %s ===\n", c->name);
        for (idx = 0; c->args && c->args[idx]; idx++)
            printf("  arg[%d]: %s\n", idx, c->args[idx]);
        printf("  fd_in = %d, fd_out = %d\n", c->fd_in, c->fd_out);
        c = c->next;
    }
} */


/* ======= fichier: ./Parsing/tokenize.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/08 18:41:00 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/04 20:03:28 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	get_token_type(char *str)
{
	if (!ft_strcmp(str, "<"))
		return (INPUT);
	if (!ft_strcmp(str, "<<"))
		return (HEREDOC);
	if (!ft_strcmp(str, ">"))
		return (OUTPUT);
	if (!ft_strcmp(str, ">>"))
		return (APPEND);
	if (!ft_strcmp(str, "|"))
		return (PIPE);
	else
		return (ARG);
}

void	add_token(t_token **head, char *value)
{
	t_token	*new;
	t_token	*tmp;

	new = malloc(sizeof(t_token));
	if (!new)
		return ;
	new->str = ft_strdup(value);
	new->sq = false;
	new->dq = false;
	//stock_and_delete_quote(new);
	new->type = get_token_type(new->str);
	new->next = NULL;
	if (!*head)
		*head = new;
	else
	{
		tmp = *head;
		while (tmp->next)
			tmp = tmp->next;
		tmp->next = new;
	}
}

void	parse_token(t_data *data, char **tokens)
{
	int		i;
	t_token	*token_list;

	token_list = NULL;
	i = 0;
	while (tokens[i])
	{
		add_token(&token_list, tokens[i]);
		i++;
	}
	data->token = token_list;
	mark_commands(data);
/* 	t_token *tmp = token_list;
 	while (tmp)
	{
		printf("Token: %-15s | Type: %-2d | SQ: %d | DQ: %d\n", 
			tmp->str, tmp->type, tmp->sq, tmp->dq);
		tmp = tmp->next;
	} */
}

int	tokenize(t_data *data, char *line)
{
	char	**token;

	token = line_to_token(line);
	if (!token)
	{
		data->exit_code = 2;
		return (0);
	}
	parse_token(data, token);
	free_tab(token);
	return (1);
}


/* ======= fichier: ./Parsing/make_commands.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   make_commands.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/29 22:08:30 by mlavry            #+#    #+#             */
/*   Updated: 2025/05/06 15:15:58 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

bool	is_redir(int type)
{
	return (type == HEREDOC || type == INPUT
		|| type == OUTPUT || type == APPEND || type == GREAT || type == DGREAT);
}

void	mark_commands(t_data *data)
{
	t_token	*prev;
	t_token	*curr;

	prev = NULL;
	curr = data->token;
	while (curr)
	{
		if (curr->type == ARG)
		{
			if (!prev || prev->type == PIPE)
				curr->type = CMD;
		}
		prev = curr;
		curr = curr->next;
	}
}

static int	arg_count(char **args)
{
	int	i;

	i = 0;
	while (args && args[i])
		i++;
	return (i);
}

static char	**ft_grow(char **old, int size)
{
	char	**new;
	int		i;

	i = -1;
	new = malloc(sizeof(char *) * (size + 2));
	if (!new)
		return (NULL);
	while (++i < size)
		new[i] = old[i];
	new[i] = NULL;
	new[i + 1] = NULL;
	free(old);
	return (new);
}

int	add_args(char ***args, char *str)
{
	char	**tmp;
	int		nb;

	if (!*args)
	{
		*args = malloc(sizeof(char *) * 2);
		if (!*args)
			return (0);
		(*args)[0] = ft_strdup(str);
		if (!(*args)[0])
			return (0);
		(*args)[1] = NULL;
		return (1);
	}
	nb = arg_count(*args);
	tmp = ft_grow(*args, nb);
	if (!tmp)
		return (0);
	tmp[nb] = ft_strdup(str);
	if (!tmp[nb])
		return (0);
	tmp[nb + 1] = NULL;
	*args = tmp;
	return (1);
}


/* ======= fichier: ./Parsing/exit_code.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit_code.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 19:48:09 by mlavry            #+#    #+#             */
/*   Updated: 2025/05/13 21:12:23 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	free_all(t_data *data, int exit_code, bool exit_or_not)
{
	free_env(&data->env);
	free_token(&data->token);
	free_cmd(&data->cmd);
	if (data->line)
	{
		free(data->line);
		data->line = NULL;
	}
	if (exit_or_not)
	{
		clear_history();
		exit(exit_code);
	}
}

void	malloc_failed(t_data *data)
{
	ft_putstr_fd("minishell: malloc failed\n", 2);
	free_all(data, 1, true);
}


/* ======= fichier: ./Parsing/init_struct.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_struct.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/12 19:51:27 by mlavry            #+#    #+#             */
/*   Updated: 2025/05/20 17:45:00 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

/* static void	init_token(t_token *token)
{
	token->str = NULL;
	token->type = 0;
	token->sq = false;
	token->dq = false;
	token->next = NULL;
	token->prev = NULL;
}

static void	init_cmd(t_cmd *cmd)
{
	cmd->name = NULL;
	cmd->args = NULL;
	cmd->fd_in = 0;
	cmd->fd_out = 1;
	cmd->next = NULL;
} */

void	init_data(t_data *data, int argc, char **argv, char **envp)
{
	ft_bzero(data, sizeof(t_data));
	(void)envp;
	(void)argc;
	(void)argv;
	data->env = NULL;
	data->cmd = NULL;
	data->token = NULL;
	data->line = NULL;
	data->exit_code = 0;
}


/* ======= fichier: ./Parsing/line_to_token.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   line_to_token.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/15 21:47:49 by mlavry            #+#    #+#             */
/*   Updated: 2025/05/20 19:07:21 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	space_and_operator_check(char *line, int *pos)
{
	if (is_space(line[pos[1]]))
	{
		if (pos[1] > pos[0])
			pos[2]++;
		while (is_space(line[pos[1]]))
			pos[1]++;
		pos[0] = pos[1];
		return (1);
	}
	else if (is_operator(line[pos[1]]))
	{
		if (pos[1] > pos[0])
			pos[2]++;
		while (line[pos[1]] == line[pos[0]])
			pos[1]++;
		pos[2]++;
		pos[0] = pos[1];
		return (1);
	}
	return (0);
}

static void	init_var(int pos[3], bool *sq, bool *dq)
{
	pos[0] = 0;
	pos[1] = 0;
	pos[2] = 0;
	*sq = false;
	*dq = false;
}

int	is_sq(char *line, bool *sq, int *pos)
{
	int	s;

	if (*sq)
	{
		if (pos[1] > pos[0])
			pos[2]++;
		pos[1]++;
		s = pos[1];
		while (line[pos[1]] && line[pos[1]] != '\'')
			pos[1]++;
		if (pos[1] > s)
			pos[2]++;
		if (line[pos[1]] == '\'')
		{
			*sq = false;
			pos[1]++;
		}
		pos[0] = pos[1];
		return (1);
	}
	return (0);
}

int	is_dq(char *line, bool *dq, int *pos)
{
	int	s;

	if (*dq)
	{
		if (pos[1] > pos[0])
			pos[2]++;
		pos[1]++;
		s = pos[1];
		while (line[pos[1]] && line[pos[1]] != '"')
			pos[1]++;
		if (pos[1] > s)
			pos[2]++;
		if (line[pos[1]] == '"')
		{
			*dq = false;
			pos[1]++;
		}
		pos[0] = pos[1];
		return (1);
	}
	return (0);
}

int	count_tokens(char *line)
{
	int		pos[3];
	bool	sq;
	bool	dq;

	init_var(pos, &sq, &dq);
	while ( line[pos[1]])
	{
		quote_choice(&sq, &dq, line[pos[1]]);
		if (is_sq(line, &sq, pos))
			continue ;
		if (is_dq(line, &dq, pos))
			continue ;
		if (!sq && !dq)
		{
			if (space_and_operator_check(line, pos))
				continue ;
		}
		pos[1]++;
	}
	if (pos[1] > pos[0])
		pos[2]++;
	return (pos[2]);
}


/* ======= fichier: ./Parsing/free.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/22 22:31:47 by mlavry            #+#    #+#             */
/*   Updated: 2025/05/14 18:33:17 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	free_tab(char **tokens)
{
	int	i;

	if (!tokens)
		return ;
	i = 0;
	while (tokens[i])
	{
		free(tokens[i]);
		i++;
	}
	free(tokens);
}

void	close_all_fd(void)
{
	int	fd;

	fd = 3;
	if (fd > 1024)
		exit(0);
	while (fd < 1024)
	{
		close(fd);
		fd++;
	}
}

void	free_env(t_env **env)
{
	t_env	*tmp;

	if (!env || !*env)
		return ;
	while (*env)
	{
		tmp = (*env)->next;
		if ((*env)->name)
			free((*env)->name);
		if ((*env)->value)
			free((*env)->value);
		free(*env);
		*env = tmp;
	}
	*env = NULL;
}

void	free_token(t_token **token)
{
	t_token	*tmp;

	if (!token || !*token)
		return ;
	while (*token)
	{
		tmp = (*token)->next;
		if ((*token)->str)
			free((*token)->str);
		free(*token);
		*token = tmp;
	}
	*token = NULL;
}

void	free_cmd(t_cmd **cmd)
{
	t_cmd	*tmp;

	if (!cmd || !*cmd)
		return ;
	while (*cmd)
	{
		tmp = (*cmd)->next;
		if ((*cmd)->name)
			free((*cmd)->name);
		if ((*cmd)->args)
			free_tab((*cmd)->args);
		close_all_fd();
		free(*cmd);
		*cmd = tmp;
	}
	*cmd = NULL;
}


/* ======= fichier: ./Parsing/check_quote.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_quote.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/31 21:21:34 by mlavry            #+#    #+#             */
/*   Updated: 2025/04/28 16:02:24 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	quote_choice(bool *sq, bool *dq, char c)
{
	if ((c == '\'' || c == '"') && !*sq && !*dq)
	{
		if (c == '\'' && !*dq)
			*sq = true;
		if (c == '"' && !*sq)
			*dq = true;
	}
	else if (c == '\'' || c == '"')
	{
		if (c == '\'' && !*dq)
			*sq = false;
		if (c == '"' && !*sq)
			*dq = false;
	}
}

int	open_quote(t_data *data, char *line)
{
	bool	sq;
	bool	dq;
	int		i;

	sq = false;
	dq = false;
	i = 0;
	while (line[i])
	{
		quote_choice(&sq, &dq, line[i]);
		i++;
	}
	if (sq || dq)
	{
		data->exit_code = 2;
		ft_putstr_fd("open quote\n", 2);
		return (1);
	}
	return (0);
}

int	is_quoted(char c)
{
	if (c == '\'')
		return (1);
	if (c == '"')
		return (2);
	return (0);
}

void	stock_and_delete_quote(t_token *token)
{
	int		len;
	char	*tmp;

	len = (int)ft_strlen(token->str);
	if (!token || !token->str || len < 2)
		return ;
	if (token->str[0] == '\'' && token->str[len - 1] == '\'')
	{
		token->sq = true;
		tmp = ft_substr(token->str, 1, len - 2);
		if (!tmp)
			return ;
		free(token->str);
		token->str = tmp;
	}
	else if (token->str[0] == '"' && token->str[len - 1] == '"')
	{
		token->dq = true;
		tmp = ft_substr(token->str, 1, len - 2);
		if (!tmp)
			return ;
		free(token->str);
		token->str = tmp;
	}
}


/* ======= fichier: ./Parsing/parsing_start.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_start.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/08 18:55:39 by mlavry            #+#    #+#             */
/*   Updated: 2025/05/29 15:19:40 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

bool	parse_line(t_data *data)
{
	if (open_quote(data, data->line))
	{
		free(data->line);
		return (false);
	}
	replace_dollars(data);
	if (!tokenize(data, data->line))
	{
		free(data->line);
		return (false);
	}
	data->cmd = tokens_to_commands(data->token, data);
	if (!(data->cmd))
	{
		free(data->line);
		return (false);
	}
	//print_cmds(data->cmd);
	return (true);
}


/* ======= fichier: ./main.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/26 17:55:00 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/03 20:50:09 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/*void	signal_handler(int sig)
{
	if (sig == SIGINT)
	{
		ft_putstr_fd("\n", STDOUT_FILENO);
		rl_replace_line("", 0);
		if (rl_on_new_line() != 0)
			ft_putstr_fd("Error: problem with new line\n", 2);
		rl_redisplay();
	}
}*/

bool	empty_line(char *line, t_data *data)
{
	int	i;

	i = 0;
/* 	if (line[i] == '>' || line[i] == '<')
    {
		if (is_multiple_append(&line[i]) || is_multiple_heredoc(&line[i]))
		{
			data->exit_code = 2;
			return true;
		}
	}  */
	while (line[i] && (line[i] == ' ' || line[i] == ':' || line[i] == '.'))
	{
		i++;
		data->exit_code = 0;
	}
	if (line[0] == '|')
	{
		printf("bash: syntax error near unexpected token `|'\n");
		data->exit_code = 2;
		return (true);
	}
	if (line[i] == '!')
	{
		i++;
		data->exit_code = 1;
	}
	if (i == (int)ft_strlen(line))
	{
		free(line);
		return (true);
	}
	return (false);
}


int	main(int argc, char *argv[], char **envp)
{
	t_data	data;

	init_data(&data, argc, argv, envp);
	parse_env(envp, &data);
	execshell(&data, &data.env);
	emptyenv(&data, &data.env);
	while (1)
	{
		data.line = readline("minishell$ ");
		if (!data.line)
		{
			ft_putstr_fd("exit\n", 2);
			free_all(&data, 0, true);
			exit (0);
		}
		if (empty_line(data.line, &data))
			continue ;
		add_history(data.line);
		if (!parse_line(&data))
			continue ;
		else
			executecommand(&data);
		free_token(&data.token);
		free_cmd(&data.cmd);
		free(data.line);
	}
	free_all(&data, 0, true);
	clear_history();
	return (0);
}


/* ======= fichier: ./utils.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 20:29:56 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/03 16:08:07 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*ft_strcat(char *dest, char *src)
{
	int	i;
	int	o;

	i = 0;
	o = 0;
	while (dest[i] != '\0')
	{
		i++;
	}
	while (src[o] != '\0')
	{
		dest[i] = src[o];
		i++;
		o++;
	}
	dest[i] = '\0';
	return (dest);
}

char	*ft_strcpy(char *dest, const char *src)
{
	int	i;

	i = 0;
	while (src[i] != '\0')
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = '\0';
	return (dest);
}

int	ft_strcmp(char *s1, char *s2)
{
	int	i;

	if (!s1 || !s2)
		return (-1);
	i = 0;
	while (s1[i] != '\0' && s2[i] != '\0')
	{
		if (s1[i] != s2[i])
			return (s1[i] - s2[i]);
		i++;
	}
	return (s1[i] - s2[i]);
}

int	str_append(char **res, int *len_buf, const char *add)
{
	size_t	add_len;
	char	*new;

	add_len = ft_strlen(add);
	new = malloc((size_t)(*len_buf + add_len) + 1);
	if (!new)
		return (0);
	if (*res)
	{
		ft_memcpy(new, *res, *len_buf);
		free(*res);
	}
	ft_memcpy(new + *len_buf, add, add_len + 1);
	*res = new;
	*len_buf += add_len;
	return (1);
}

int	char_append(char **res, int *len_buf, char c)
{
	char	tmp[2];

	tmp[0] = c;
	tmp[1] = '\0';
	return (str_append(res, len_buf, tmp));
}


/* ======= fichier: ./utils_2.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_2.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/20 17:46:33 by mlavry            #+#    #+#             */
/*   Updated: 2025/05/20 17:46:51 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_operator(char c)
{
	if (c == '|' || c == '<' || c == '>')
		return (1);
	return (0);
}

int	is_space(char c)
{
	if (c == ' ' || (c >= 9 && c <= 13))
		return (1);
	return (0);
}

int	big_heredoc(char *str, int i)
{
	if (ft_strcmp(&str[i], "<<<<") == 0)
	{
		printf("bash: syntax error near unexpected token `<'\n");
		return (1);
	}
	else if (ft_strcmp(&str[i], "<<<<<") == 0)
	{
		printf("bash: syntax error near unexpected token `<<'\n");
		return (1);
	}
	return (0);
}

int	is_multiple_heredoc(char *str)
{
	int	i;

	i = 0;
	while (str[i])
	{
		if (big_heredoc(str, i))
			return (1);
		if (ft_strcmp(&str[i], "<") == 0 || ft_strcmp(&str[i], "<<") == 0
			|| ft_strcmp(&str[i], "<<<") == 0)
		{
			printf("bash: syntax error near unexpected token `newline'\n");
			return (1);
		}
		else
		{
			while (str[i] == '<')
			{
				printf("bash: syntax error near unexpected token `<<<'\n");
				return (1);
			}
		}
		i++;
	}
	return (0);
}


int	is_multiple_append(char *str)
{
	while (*str)
	{
		if (ft_strcmp(str, ">>>") == 0)
		{
			printf("bash: syntax error near unexpected token `>'\n");
			return (1);
		}
		else if (ft_strcmp(str, ">") == 0 || ft_strcmp(str, ">>") == 0)
		{
			printf("bash: syntax error near unexpected token `newline'\n");
			return (1);
		}
		else
		{
			while (*str == '>')
			{
				printf("bash: syntax error near unexpected token `>>'\n");
				return (1);
			}
		}
		str++;
	}
	return (0);
}



/* ======= fichier: ./utils_3.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_3.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlavry <mlavry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/02 23:44:24 by mlavry            #+#    #+#             */
/*   Updated: 2025/06/04 21:31:59 by mlavry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	ft_isnumeric(const char *str)
{
	int	i;

	i = 0;
	if (!str || !*str)
		return (0);
	while (is_space(str[i]))
		i++;
	if (str[i] == '+' || str[i] == '-')
		i++;
	while (str[i])
	{
		if (!ft_isdigit(str[i]) && !is_space(str[i]))
			return (0);
		i++;
	}
	return (1);
}

int	check_operators(char *line, char **tokens, int *pos)
{
	char	quote_actual;
	int		old_pos;

	old_pos = pos[1] - 1;
	quote_actual = line[pos[1] - 1];
	while (is_operator(line[pos[1]]))
		pos[1]++;
	if (line[pos[1]] == quote_actual && (!line[pos[1] + 1]
			|| is_space(line[pos[1] + 1])))
	{
		tokens[pos[2]++] = ft_substr(line, pos[0] - 1, pos[1] - pos[0] + 2);
		pos[0] = pos[1];
		return (1);
	}
	pos[1] = old_pos;
	pos[0] = pos[1];
	return (0);
}


/* ======= fichier: ./Gnl/get_next_line.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aboutale <aboutale@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/11 17:33:23 by aboutale          #+#    #+#             */
/*   Updated: 2025/03/13 17:48:56 by aboutale         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"

int	readbuffer(int fd, char **buffer)
{
	int		readchar;
	char	*temp ;
	char	*newbuffer;

	temp = malloc(sizeof(char) * BUFFER_SIZE +1);
	if (!temp)
		return (-1);
	readchar = read(fd, temp, BUFFER_SIZE);
	if (readchar < 0)
	{
		free(temp);
		return (readchar);
	}
	temp[readchar] = '\0';
	newbuffer = ft_strjoin(*buffer, temp);
	free(temp);
	if (!newbuffer)
		return (-1);
	free(*buffer);
	*buffer = newbuffer;
	return (readchar);
}

char	*extractline(char *buffer)
{
	int		i;
	int		j;
	char	*line;

	line = NULL;
	i = 0;
	if (!buffer)
		return (NULL);
	while (buffer[i] != '\n' && buffer[i])
		i++;
	if (buffer[i] == '\n')
		i++;
	line = (char *)malloc(sizeof(char) * (i + 1));
	if (!line)
		return (NULL);
	j = 0;
	while (j < i)
	{
		line[j] = buffer[j];
		j++;
	}
	line[j] = '\0';
	return (line);
}

int	refreshbuffer(char **buffer)
{
	int		i;
	char	*newbuffer;

	i = 0;
	while ((*buffer)[i] != '\n' && (*buffer)[i] != '\0')
		i++;
	newbuffer = NULL;
	if ((*buffer)[i] == '\n')
	{
		if (ft_strlen(*buffer) - i > 0)
		{
			newbuffer = ft_strdup(&(*buffer)[i + 1]);
			if (!newbuffer)
				return (-1);
		}
		free(*buffer);
		*buffer = newbuffer;
	}
	else
	{
		free(*buffer);
		*buffer = NULL;
	}
	return (0);
}

int	nextline(int fd, char **buffer, char **line)
{
	int	readchar;

	readchar = readbuffer(fd, buffer);
	while ((readchar > 0))
	{
		if (ft_strchr(*buffer, '\n'))
		{
			*line = extractline(*buffer);
			if (!*line)
				return (-1);
			if (refreshbuffer(buffer) == -1)
				return (-1);
			return (1);
		}
		readchar = readbuffer(fd, buffer);
	}
	if (readchar == 0 && *buffer && **buffer != '\0')
	{
		*line = ft_strdup(*buffer);
		free(*buffer);
		*buffer = NULL;
		return (1);
	}
	free(*line);
	return (0);
}

char	*get_next_line(int fd)
{
	static char	*buffer[1024];
	char		*line;

	line = NULL;
	if (fd < 0 || BUFFER_SIZE <= 0 || fd > 1023)
		return (NULL);
	if (!buffer[fd])
		buffer[fd] = ft_strdup("");
	if (!buffer[fd])
		return (NULL);
	if (*buffer[fd] && ft_strchr(buffer[fd], '\n'))
	{
		line = extractline(buffer[fd]);
		refreshbuffer(&buffer[fd]);
		return (line);
	}
	if (nextline(fd, &buffer[fd], &line) > 0)
		return (line);
	return (free(buffer[fd]), buffer[fd] = NULL, NULL);
}


/* ======= fichier: ./Gnl/get_next_line_utils.c ======= */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aboutale <aboutale@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/13 17:25:33 by aboutale          #+#    #+#             */
/*   Updated: 2024/12/06 16:16:12 by aboutale         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"

size_t	ft_strlen(const char *s)
{
	size_t	i;

	i = 0;
	if (s)
		while (s[i] != '\0')
			i++;
	return (i);
}

char	*ft_strdup(const char *s)
{
	char	*dup;
	int		i;

	i = 0;
	if (!s)
		return (NULL);
	while (s[i])
		i++;
	dup = (char *)malloc(i + 1);
	if (!dup)
		return (NULL);
	i = 0;
	while (s[i])
	{
		dup[i] = s[i];
		i++;
	}
	dup[i] = '\0';
	return (dup);
}

void	*ft_calloc(size_t nmemb, size_t size)
{
	void	*p;
	size_t	i;

	if (size != 0 && (nmemb * size) / size != nmemb)
		return (NULL);
	p = malloc(nmemb * size);
	if (!(p))
		return (NULL);
	i = 0;
	while (i < size * nmemb)
	{
		((char *)p)[i] = '\0';
		i++;
	}
	return (p);
}

/* char	*ft_strjoin(char *s1, char *s2)
{
	char	*joi;
	int		i;
	int		j;

	i = 0;
	j = 0;
	if (!s2 || !s1)
		return (NULL);
	joi = (char *)ft_calloc(sizeof(char), (ft_strlen(s1) + ft_strlen(s2) + 1));
	if (joi == NULL)
		return (NULL);
	while (s1[i])
	{
		joi[i] = s1[i];
		i++;
	}
	while (s2[j])
	{
		joi[i + j] = s2[j];
		j++;
	}
	return (joi);
} */

char	*ft_strchr(const char *s, int c)
{
	int	i;

	i = 0;
	while (s[i])
	{
		if (s[i] == (unsigned char) c)
			return ((char *)&s[i]);
		i++;
	}
	if ((unsigned char)c == '\0')
		return ((char *)&s[i]);
	return (NULL);
}


/* ======= fichier: ./Gnl/main.c ======= */
/* ************************************************************************** */
/*																			*/
/*														:::	  ::::::::   */
/*   main.c											 :+:	  :+:	:+:   */
/*													+:+ +:+		 +:+	 */
/*   By: aboutale <aboutale@student.42.fr>		  +#+  +:+	   +#+		*/
/*												+#+#+#+#+#+   +#+		   */
/*   Created: 2024/11/20 12:21:47 by aboutale		  #+#	#+#			 */
/*   Updated: 2024/11/22 18:14:11 by aboutale		 ###   ########.fr	   */
/*																			*/
/* ************************************************************************** */

#include "get_next_line.h"
#include <stdio.h>

int main()
{
	int fd = open("gnlfile", O_RDONLY); 
	int fd2 = open("gnlfile", O_RDONLY);
	char *line;
	char *line2;
   // size_t readbytes;
   // line = get_next_line(fd);
   // readbytes = read(fd, line, BUFFER_SIZE);
	if (fd == -1)
	{
		perror("Erreur d'ouverture");
		return (1);
	}
	while ((line = get_next_line(fd)) != NULL && (line2 = get_next_line(fd2)) != NULL)
	{
		printf("%s", line);
		printf("%s", line2);
		free(line);
		free(line2);
	}  
	// line = get_next_line(fd);
	// printf("%s", line);
	// free(line);
	// line = get_next_line(fd);
	// printf("%s", line);
	// free(line);
	close(fd);
	close(fd2);
	return (0);
}  


/*       #include <stdio.h>

int main() {
    int fd = open("gnlfile", O_RDONLY); 
    char *line;

    if (fd == -1)
    {
        perror("Erreur d'ouverture");
        return (1);
    }

    while ((line = get_next_line(fd)) != NULL)
    {
        printf("%s", line);
        free(line); 
      
    }

    close(fd);
    return (0);
}      */ 

